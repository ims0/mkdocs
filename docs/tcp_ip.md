# 

## [TCP/IP详解 卷1：协议](http://www.52im.net/topic-tcpipvol1.html?mobile=no)

### IP服务的特点
  IP协议是TCP/IP协议族的动力，他为上层协议提供无状态、无连接、不可靠的服务。
#### 无状态：
  是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接受都是相互独立的、没有上下文关系的。
+ 缺点是无法处理乱序的和重复的IP数据报。接收端只负责将其数据部分交给上层协议，比如TCP协议，由它处理乱序的、重复的数据。
虽然IP数据报头部提供了一个标识字段用以唯一标识一个IP数据报，但它是被用来处理IP分片和重组的，而不是用来指示接收顺序的。
+ 优点是简单高效。无需为保持通信状态分配内核资源，也无需每次传输数据时都携带状态信息。
#### 无连接：
  是指IP通信双方都不长久地维持对方的任何信息。所以上层协议发送数据时，都必须明确指定对方的IP地址。
#### 不可靠：
  是指IP协议不能保证IP数据报准确地到达接受端，他只是承诺尽最大努力。就是说，发生任何意外导致IP数据报发送失败，它就通知上层协议发送失败，因此，使用IP服务的上层协议需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。


### IPv4头部结构
长度通常为20字节，除非有可变长的选项部分

![avatar](tcp_ip_pic/ip.jpg)
横着一行为32个bit，为四个字节。

+ **4位版本号** 指定IP协议的版本。对IPv4来说，为4。

+ **4位头部长度** 标识该IP头部有多少个32bit(即多少行),四位最大表示15，所以IP头部最长为60字节。

+ **8位服务类型** 包括一个三位的优先权字段(现在已忽略)四位的TOS字段和一位保留字段(保留需置0).四位的TOS字段分别表示：最小延时，最大吞吐量，最高可靠性和最小费用。这四位中最多只有一位置1。应用程序根据需要设置(比如ssh需要最小延时，ftp需要最大吞吐量)。

+ **16位总长度** 是指整个IP数据报的长度，以字节为单位，因此IP数据报最大长度为65535-1字节。但由于MTU的限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP数据报的长度都远远没有达到最大值。

+ **16位标识：** 唯一地标识主机发送的每一个数据报。其初始值由系统随机生成，每发送一个数据报，其值就加一。该值在数据报分片时被复制到每个分片中，因此同一个数据报的所有分片都具有相同的标识符。

+ **3位标志字段：** 第一位保留。第二位标识禁止分片。设置后，IP将不对该数据报分片，当该数据报长度超过MTU时，IP模块将丢弃该数据包并返回一个ICMP差错报文。第三位表示更多分片。除了数据报的最后一个分片外，其他分片都要把该位置1.

+ **13位分片偏移** 是分片相对原始IP数据报开始处(仅指数据部分)的偏移。实际的偏移值是该值左移三位(乘8)后得到的。因此，每个IP分片的数据部分的长度必须是8的整数倍。

+ **8位生存时间TTL(time to live)：** 是数据报到达目的地之前允许经过的路由器跳数。发送端设置(通常是64)。数据报每经过一次路由，该值就被路由器减一，为零时，路由器将丢弃该数据报，并向源端发送一个ICMP差错报文。TTL可以防止数据报陷入路由循环。

+ **8位协议：** 用来区分上层协议。/etc/protocols文件定义了所有上层协议对应的字段的数值。例如，ICMP是1，TCP是6，UDP是17。

+ **16位头部校验和：** 由发送端填充，接收端对其使用CRC算法检验头部在数据传输过程中是否损坏。

+ **32位源端IP地址：** 用来表示IP数据报的发送端

+ **32位目的端IP地址：** 用来表示IP数据报的接收端

+ **选项字段：** 是可变长的可选信息。最多包含40字节，可用的选项有：

记录路由：将途径的路由器的ip地址填入选项部分，用于跟踪数据报的传递路径。时间戳：告诉每个路由器将数据报被转发的时间(或时间与IP地址对)填入IP头部的选项部分，这样就可以测量途径路由之间数据报传输的时间。

松散路由选择：指定路由IP地址列表，数据包发送过程必须经过其中所有路由器。

严格路由选择：数据报只能经过被指定的路由器。


原文链接：https://blog.csdn.net/weixin_44135544/article/details/103162399

---
## UDP 协议

###  udp 8字节头结构

udp头比tcp多了报文长度字段，tcp的报文长度有ip头指定

![avatar](tcp_ip_pic/udp_head.jpg)

![avatar](tcp_ip_pic/udp_ip.jpg)

---


## TCP 协议部分
### 1. TCP头部分析与确认号的理解
![avatar](tcp_ip_pic/tcp_header_en.jpg)
![avatar](tcp_ip_pic/tcp_ch.png)

+ **源端口号和目的端口号**：再加上Ip首部的源IP地址和目的IP地址可以唯一确定一个TCP连接
+ **数据序号**：表示在这个报文段中的第一个数据字节序号
+ **确认序号**：仅当ACK标志为1时有效。确认号表示期望收到的下一个字节的序号（这个下面再详细分析）
+ **偏移**：就是头部长度，有4位，跟IP头部一样，以4字节为单位。最大是60个字节
+ **保留位**：6位，必须为0
+ 6个标志位：
1. URG-紧急指针有效
2. ACK-确认序号有效
3. PSH-接收方应尽快将这个报文交给应用层
4. RST-连接重置
5. SYN-同步序号用来发起一个连接
6. FIN-终止一个连接

+ **窗口字段**：16位，代表的是窗口的字节容量，也就是TCP的标准窗口最大为2^16 - 1 = 65535个字节

+ **校验和**：源机器基于数据内容计算一个数值，收信息机要与源机器数值 结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。

+ **紧急指针**：是一个正偏移量，与序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式
+ **选项与填充**（必须为4字节整数倍，不够补0）：
最常见的可选字段的最长报文大小MSS（Maximum Segment Size），每个连接方通常都在一个报文段中指明这个选项。它指明本端所能接收的最大长度的报文段。
该选项如果不设置，默认为536（20+20+536=576字节的IP数据报）

### 2.TCP如何保证可靠性

* 1）应用数据被分割成TCP认为最合适发送的数据块。称为段（Segment）传递给IP层
* 2）当TCP发出一个段后，它会启动一个定时器，等待目的端确认收到这个报文段。若没有及时收到确认，将重新发送这个报文段
* 3）当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送的，通常将推迟200ms。
* 4）TCP将保持它首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的校验和有差错，TCP将丢弃这个报文也不进行确认（对方就会重复发送了）。
* 5）TCP承载与IP数据报来传输，而IP数据报可能会失序，所以TCP的报文段到达时也可能会失序。但是TCP收到数据后会重新排序到正确的顺序（通过序号）。
* 6）IP数据报会发生重复，TCP的接收端必须丢弃重复是数据
* 7）TCP还能提供流量控制，TCP连接的每一方都有一定大小的缓冲空间

### ACK延迟确认机制
接收方在收到数据后，并不会立即回复ACK,而是延迟一定时间。一般ACK延迟发送的时间为200ms，但这个200ms并非收到数据后需要延迟的时间。系统有一个固定的定时器每隔200ms会来检查是否需要发送ACK包。
这样做有两个目的:

1. 这样做的目的是ACK是可以合并的，也就是指如果连续收到两个TCP包，并不一定需要ACK两次，只要回复最终的ACK就可以了，可以降低网络流量。
2. 如果接收方有数据要发送，那么就会在发送数据的TCP数据包里，带上ACK信息。这样做，可以避免大量的ACK以一个单独的TCP包发送，减少了网络流量。

### [TCP 四个计时器](https://blog.csdn.net/qq_33951180/article/details/60468267)

TCP中的四个计时器包括重传计时器、坚持计时器、保活计时器、时间等待计时器

#### 1. 重传计时器(Retransmission Timer)：

目的：为了控制丢失的报文段或者丢弃的报文段。这段时间为对报文段的等待确认时间。
#### 2.  坚持计时器(Persistent Timer)：

目的：主要解决零窗口大小通知可能导致的死锁问题

#### 3. 保活计时器(Keeplive Timer)：

目的：主要是为了防止两个TCP连接出现长时间的空闲。当客户端与服务器端建立TCP连接后，很长时间内客户端都没有向服务器端发送数据，此时很有可能是客户端出现故障，而服务器端会一直处于等待状态。保活计时器就是解决这种问题而生的。

#### 4. 时间等待计时器(Time_Wait Timer)：

时间等待计时器是在连接终止期间使用的。

### [TCP的半关闭 与rsh](http://docs.52im.net/extend/docs/book/tcpip/vol1/18/)

TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的半关闭。
为了使用这个特性，编程接口必须为应用程序提供一种方式来说明“我已经完成了数据传送，因此发送一个文件结束（FIN）给另一端，但我还想接收另一端发来的数据，直到它给我发来文件结束（FIN）”.

命令
`sun % rsh bsdi sort < datafile`

+ 没有半关闭，需要其他的一些技术让客户通知服务器,客户端已经完成了它的数据传送，但仍要接收来自服务器的数据。



-------------
### 3. 滑动窗口协议（也就是对包头中窗口字段的理解）

[TCP拥塞控制-慢启动、拥塞避免、快重传、快启动](https://blog.csdn.net/jtracydy/article/details/52366461)

参考1：https://www.cnblogs.com/ulihj/archive/2011/01/06/1927613.html

参考2：http://blog.chinaunix.net/uid-26275986-id-4109679.html

先上两个概念：
通告接收窗口（rwnd）：预防应用程序发送的数据超过对方的缓冲区，接收方使用的流量控制。
拥塞窗口（cwnd）：预防应用程序发送的数据超过了网络所能承载的能力。发送方使用的流量控制。
发送窗口：就是指上面两者的较小值

由于TCP的全双工的，所以其实TCP双方各自都维护一个发送窗口和接收窗口。

假设是主机A发送给主机B
A和B都会维护一个数据帧的序列，这个序列称为窗口。发送方的窗口大小由接收方确定。目的在于控制发送速度。以免接收方的缓存不够大而导致溢出，同时流量控制也可以避免网络拥塞。
这里其实是指A的发送窗口。

![avatar](tcp_ip_pic/tcp_window.png)

### 4. keepalive 用途
+ TCP的keepalive是侧重在保持客户端和服务端的连接，一方会不定期发送心跳包给另一方，当一方端掉的时候，没有断掉的定时发送几次心跳包，如果间隔发送几次，对方都返回的是RST，而不是ACK，那么就释放当前链接。设想一下，如果tcp层没有keepalive的机制，一旦一方断开连接却没有发送FIN给另外一方的话，那么另外一方会一直以为这个连接还是存活的，几天，几月。那么这对服务器资源的影响是很大的。

+ HTTP的keep-alive一般我们都会带上中间的横杠，普通的http连接是客户端连接上服务端，然后结束请求后，由客户端或者服务端进行http连接的关闭。下次再发送请求的时候，客户端再发起一个连接，传送数据，关闭连接。这么个流程反复。但是一旦客户端发送connection:keep-alive头给服务端，且服务端也接受这个keep-alive的话，两边对上暗号，这个连接就可以复用了，一个http处理完之后，另外一个http数据直接从这个连接走了。减少新建和断开TCP连接的消耗。

作者：Katou_Megumi
链接：https://www.jianshu.com/p/9fe2c140fa52
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


### 5.关于包头中确认号ack的理解

确认序号：仅当ACK标志为1时有效。确认号表示期望收到的下一个字节的序号
经受时延的确认（Delay ACK）:http://www.vants.org/?post=114

### 传输数据的简要过程如下：

* 1）发送数据：服务器向客户端发送一个带有数据的数据包。该数据包中的序列号和确认号与建立连接第三步的数据包找那个的序列号和确认号相同。
* 2）确认收到：客户端收到该数据包，向服务器发送一个确认数据包。该数据包中，序列号是为上一个数据包中的确认号值。
而确认号为服务器发送的上一个数据包中的序列号+该数据包中所带数据的大小。回复确认收到的ack = 收到了序列号 + 数据的大小（同时也表示下一次期望收到的序号）


### nc 测试交互过程的sn、ack 变化

服务端监听本地端口3000

`nc -lv localhost 3000`

客户端连接本地端口 3000

`nc -v localhost 3000`

tcpdump 查看交互消息

`tcpdump -pnv -i lo port 3000`

+ [三次握手与三次挥手的交互](tcp_ip_pic/tcp_ip_interactive.pcap)

![avatar](tcp_ip_pic/tcp_ip_interactive.JPG)

## ICMP (Internet控制报文协议）

ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

### ICMP 应用(ping tracert)
ICMP 协议应用在许多网络管理命令中，下面以 ping 和 traceroute 命令为例。 

#### ping 命令
在网络可达性测试中使用的分组网间探测命令 ping 能产生 ICMP 回送请求和应答报文。目的主机收到 ICMP 回送请求报文后立刻回送应答报文，若源主机能收到 ICMP 回送应答报文，则说明到达该主机的网络正常。

#### traceroute 查路由

首先发送TTL为1的 UDP 报文，然后每次将TTL字段加1，路由器收到TTL为 0、1的报文后不转发直接丢弃，并给信源机发一份**ICMP超时信息**，如果是目的主机，就是TTL是1也不会丢弃，不过由于端口大于3000，会产生**端口不可达错误的ICMP**报文。

### ping 命令执行过程

#### 同一网段

1. ping通知系统建立一个固定格式的ICMP请求数据包

2. ICMP协议打包这个数据包和机器B的IP地址转交给IP协议层（一组后台运行的进程，与ICMP类似）

3. IP层协议将以机器B的IP地址为目的地址，本机IP地址为源地址，加上一些其他的控制信息，构建一个IP数据包

4. 获取机器B的MAC地址

+ IP层协议通过机器B的IP地址和自己的子网掩码，发现它跟自己属同一网络，就直接在本网络查找这台机器的MAC

+ 若两台机器之前有过通信，在机器A的ARP缓存表应该有B机IP与其MAC的映射关系

+ 若没有，则发送ARP请求广播，得到机器B的MAC地址，一并交给数据链路层

+ 数据链路层构建一个数据帧，目的地址是IP层传过来的MAC地址，源地址是本机的MAC地址，再附加一些控制信息，依据以太网的介质访问规则，将他们传送出去

+ 机器B收到这个数据帧后，先检查目的地址，和本机MAC地址对比

+ 符合，接收。接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP协议层协议。IP层检查后，将有用的信息提取交给ICMP协议，后者处理后，马上构建一个ICMP应答包，发送给主机A，其过程和主机A发送ICMP请求包到主机B类似（这时候主机B已经知道了主机A的MAC地址，不需再发ARP请求）

+ 不符合，丢弃

#### 不同网段

1. ping通知系统建立一个固定格式的ICMP请求数据包

2. ICMP协议打包这个数据包和机器B的IP地址转交给IP协议层（一组后台运行的进程，与ICMP类似）

3. IP层协议将以机器B的IP地址为目的地址，本机IP地址为源地址，加上一些其他的控制信息，构建一个IP数据包

4. 获取主机B的MAC地址

IP协议通过计算发现主机B与自己不在同一网段内，就直接交给路由处理，就是将路由的MAC取过来，至于怎么得到路由的MAC地址，和之前一样，先在ARP缓存表中寻找，找不到可以利用广播。路由得到这个数据帧之后，再跟主机B联系，若找不到，就向主机A返回一个**超时信息**。


#### 返回信息分析

1. Request timed out

+ 对方已关机，或者网络上没有这个地址
+ 对方与自己不在同一网段内，通过路由也无法到达
+ 对方存在，不过设置了ICMP数据包过滤（比如防火墙设置）
+ 错误设置IP地址

2. Destination host Unreachable

+ 自己未设定默认路由，对方跟自己不在同已网段
+ 网线有问题

3. Bad ip address

+ 没有连接到DNS服务器，无法解析IP，也可能是IP不存在

4. Source quench received

+ 对方或中途服务器繁忙而无法应答

5. Unkonw host

+ 远程主机的名字不能被域名服务器转换成IP地址，故障原因可能是DNS服务器有故障，或者名字不正确，或者网络管理员的系统与远程主机之间的通信线路故障。

6. No answer

+ 无响应。说明本地系统有一条通向中心主机的路由，但却接收不到它发给该中心主机的人呢和信息。故障原因可能是：中心主机没有工作；本地或中心主机网络配置不正确；本地或中心的路由器没有工作；通信线路有故障；中心主机存在路由选择问题。

7. Ping 127.0.0.1

+  如果ping不通，则表明本地址TCP/IP协议不能正常工作

8. no rout to host

+ 网卡工作不正常

9. transmit failed。error code

+  10043网卡驱动不正常

10. unknown host name

+ DNS配置不正确



----
## SOCKET
### socket大致介绍
  由于现在是面向对象的编程，一些计算机行业的大神通过抽象的理念，在现实中通过反复的理论或者实际的推导，提出了抽象的一些通信协议，基于tcp/ip协议，提出大致的构想，一些泛型的程序大牛在这个协议的基础上，将这些抽象化的理念接口化，针对协议提出的每个理念，专门的编写制定的接口，与其协议一一对应，形成了现在的socket标准规范，然后将其接口封装成可以调用的接口，供开发者使用
![avatar](tcp_ip_pic/socket_site.png)
![avatar](tcp_ip_pic/socket_process.png)


### Socket Func
#### socket
```
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
int socket(int domain, int type, int protocol);
```
+ domain:协议族， AF_INET/AF_INET6
+ type:类型， SOCK_STREAM/SOCK_DGRAM
+ protocol：协议,0自动选择，/etc/protocols

#### bind

```
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```
+ 当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。

+ addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同
+ addrlen：对应的是地址的长度。

+ 通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。



#### listen 

```
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
int listen(int sockfd, int backlog);
```
listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。

#### connect
```
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```
connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。

#### accept
```
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```
当connect到达时候，accept中的fd变为可写，当三次握手完成，accept从监听队列中取出这个完成的fd，如果握手失败，协议会把这个fd从监听队列中删除，accept会继续阻塞。所以IO服用的服务端监听fd一般设置为非阻塞。

#### 收发函数

```
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);

ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
              const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                struct sockaddr *src_addr, socklen_t *addrlen);

ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
```



-----------------

## 网络编程

### 设置socket为非阻塞non-blocking
使用socket()创建的socket(file descriptor)，默认是阻塞的(blocking)；使用函数fcntl()(file control)可设置创建的socket为非阻塞的non-blocking。
```
#include <unistd.h>
#include <fcntl.h>

sock = socket(PF_INET, SOCK_STREAM, 0);

int flags = fcntl(sock, F_GETFL, 0);
fcntl(sock, F_SETFL, flags | O_NONBLOCK); 
```

### select
```
int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout);
``` 
1. int maxfdp是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！
在Windows中这个参数的值无所谓，可以设置不正确。 
　　
2. fd_set *readfds是指向fd_set结构的指针，这个集合中应该包括文件描述符，
我们是要监视这些文件描述符的读变化的，即我们关心是否可以从这些文件中读取数据了，
如果这个集合中有一个文件可读，select就会返回一个大于0的值，表示有文件可读，
如果没有可读的文件，则根据timeout参数再判断是否超时，若超出timeout的时间，select返回0，
若发生错误返回负值。可以传入NULL值，表示不关心任何文件的读变化。 
　　
3. fd_set *writefds是指向fd_set结构的指针。 
　　
4. fd_set *errorfds同上面两个参数的意图，用来监视文件错误异常。 
　　
struct timeval* timeout是select的超时时间，这个参数至关重要，它可以使select处于三种状态：
第一，若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；
第二，若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；
第三，timeout的值大于0，这就是等待的超时时间，即 select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。

返回值： 

负值：select错误; 正值：某些文件可读写或出错; 0：等待超时，没有可读写或错误的文件

struct fd_set 是fd集合由宏来操作，

1. 比如清空集合 FD_ZERO(fd_set *)，
2. 将一个给定的文件描述符加入集合之中FD_SET(int ,fd_set *)，
3. 将一个给定的文件描述符从集合中删除FD_CLR(int ,fd_set*)，
4. 检查集合中指定的文件描述符是否可以读写FD_ISSET(int ,fd_set* )。

connect():
connect 可以立刻返回，根据返回值和 errno 处理三种情况：
(1) 如果返回 0，表示 connect 成功。
(2) 如果返回值小于 0， errno 为 EINPROGRESS,  表示连接
      建立已经启动但是尚未完成。这是期望的结果，不是真正的错误。
(3) 如果返回值小于0，errno 不是 EINPROGRESS，则连接出错了。

## 网络问题汇总

[后台总结](https://www.cnblogs.com/liuzhi/p/4036840.html)

### tcp与udp的差异

 TCP是一种面向连接的、可靠的、字节流服务

1. 面向链接：TCP面向链接，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须通过三次握手先建立一个TCP连接。在一个TCP中仅有两方彼此通信，多播和广播不能用于TCP。UDP是不可靠的传输，传输前不需要建立链接，可以应用多播和广播实现一对多的通信。

2. 可靠性：TCP提供端到端的流量控制，对收到的数据进行确认，采用超时重发，对失序的数据进行重新排序等机制保证数据通信的可靠性。而UDP是一种不可靠的服务，接收方可能不能收到发送方的数据报。

3. TCP是一种流模式的协议，UDP是一种数据报模式的协议。进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。TCP应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系。TCP会有粘包和半包的现象。

4. 效率上：速度上，一般TCP速度慢，传输过程中需要对数据进行确认，超时重发，还要对数据进行排序。UDP没有这些机制所以速度快。数据比例，TCP头至少20个字节，UDP头8个字节，相对效率高。组装效率上：TCP头至少20个字节，UDP头8个字节，系统组装上TCP相对慢。

5. 用途上：用于TCP可靠性，http，ftp使用。而由于UDP速度快，视频，在线游戏多用UDP，保证实时性

对于第三点的理解。TCP可能发送100个“包”，而接收到50个“包”，不是丢“包”了，而是每次接受的“包”都比发送的多，其实TCP并没有包的概念。例如，每次发10个字节，可能读得时候一次读了20个字节。TCP是一种流模式的协议，在接收到的缓存中按照发送的包得顺序自动按照顺序拼接好，因为数据基本来自同一个主机，而且是按照顺序发送过来的，TCP的缓存中存放的就是，连续的数据。感觉好像是多封装了一步比UDP。而UDP因为可能两个不同的主机，给同一个主机发送，（一个端口可能收到多个应用程序的数据），或者按照TCP那样合并数据，必然会造成数据错误。我觉得关键的原因还是，TCP是面向连接，而UDP是无连接的，这就导致，TCP接收的数据为一个主机发来且有序无误的，而UDP可能是多个主机发来的无序，可能错误的。

---

### time_wait 产生的原因

如下图所示：主动关闭的那端 在发送ACK后会经历这个状态，该状态持续时间是最长分节生命期(maximum segment lifetime, MSL)的两倍，也称2MSL

![avatar](tcp_ip_pic/net_state_conv.png)

#### 主动关闭方经历的状态有:
1. `FIN_WAIT_1 --> TIME_WAIT ` :同时收到 FIN 与ACK
2. `FIN_WAIT_1 --> CLOSING --> TIME_WAIT` :先收到 ACK,后收到 FIN, 被动方应该是先发了FIN后发ACK. 
3. `FIN_WAIT_1 --> FIN_WAIT_2 --> TIME_WAIT` : 先收到ACK，后收到FIN

#### 被动关闭方经历的状态有:
1. `CLOSE_WAIT --> LAST_ACK --> CLOSED` 

#### time_wait 存在的两个理由：
1. 可靠的实现TCP全双工连接的终止。
2. 允许老的重复分节在网络中消逝。

详细解释：

1. 防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失，Linux可以`cat /proc/sys/net/ipv4/tcp_fin_timeout`看这个值默认60））
2. 可靠的关闭TCP连接 在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发 fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以 主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 

#### 让每个TIME_WAIT早点过期,在linux上可以这么配置：

+ 让 **TIME_WAIT** 尽快回收，我也不知是多久，观察大概是一秒钟
    `echo "1" > /proc/sys/net/ipv4/tcp_tw_recycle`
+ 让TIME_WAIT状态可以重用，这样即使TIME_WAIT占满了所有端口，也不会拒绝新的请求造成障碍
    `echo "1" > /proc/sys/net/ipv4/tcp_tw_reuse`

很多文档都会建议两个参数都配置上，但是我发现只用修改tcp_tw_recycle就可以解决问题的了，TIME_WAIT重用TCP协议本身就是不建议打开的。

不能重用端口可能会造成系统的某些服务无法启动，比如要重启一个系统监控的软件，它用了40000端口，而这个端口在软件重启过程中刚好被使用了，就可能会重启失败的。linux默认考虑到了这个问题，有这么个设定：

+ 查看系统本地可用端口极限值
    `cat /proc/sys/net/ipv4/ip_local_port_range`

用这条命令会返回两个数字，默认是：32768 61000，说明这台机器本地能向外连接61000-32768=28232个连接，注意是本地向外连接，不是这台机器的所有连接，不会影响这台机器的80端口的对外连接数。但这个数字会影响到代理服务器（nginx）对app服务器的最大连接数，因为nginx对app是用的异步传输，所以这个环节的连接速度很快，所以堆积的连接就很少。



### 列举你所知道的tcp选项

1.窗口扩大因子TCP Window Scale Option (WSopt)

TCP窗口缩放选项是用来增加TCP接收窗口的大小而超过65536字节。

2.SACK选择确认选项

最大报文段长度（M S S）表示T C P传往另一端的最大块数据的长度。当建立一个连接时，每一方都有用于通告它期望接收的 M S S选项（M S S选项只能出现在S Y N报文段中）。通过MSS，应用数据被分割成TCP认为最适合发送的数据块，由TCP传递给IP的信息单位称为报文段或段(segment)。

TCP通信时，如果发送序列中间某个数据包丢失，TCP会通过重传最后确认的包开始的后续包，这样原先已经正确传输的包也可能重复发送，急剧降低了TCP性能。为改善这种情况，发展出SACK(SelectiveAcknowledgment, 选择性确认)技术，使TCP只重新发送丢失的包，不用发送后续所有的包，而且提供相应机制使接收方能告诉发送方哪些数据丢失，哪些数据重发了，哪些数据已经提前收到等。

3.MSS:Maxitum Segment Size 最大分段大小

### connect会阻塞，怎么解决?(必考必问)

最通常的方法最有效的是加定时器；也可以采用非阻塞模式。
设置非阻塞，返回之后用select检测状态)
如果select返回可读，结果只读到0字节，什么情况？
某个套接字集合中没有准备好，可能会select内存用FD_CLR清该位为0；

### socket什么情况下可读？

每次读操作返回前都要检查是否还有剩余数据没读完，如果是的话保持数据有效标志，不这样设计的话会出现明显的不一致，那就是数据在读缓冲但没有读有效标志。


### keepalive如何使用？

设置Keepalive参数，检测已中断的客户连接 在TCP中有一个Keep-alive的机制可以检测死连接，原理很简单，TCP会在空闲了一定时间后发送数据给对方：

1. 如果主机可达，对方就会响应ACK应答，就认为是存活的。

2. 如果可达，但应用程序退出，对方就发RST应答，发送TCP撤消连接。

3. 如果可达，但应用程序崩溃，对方就发FIN消息。

4. 如果对方主机不响应ack, rst，继续发送直到超时，就撤消连接。这个时间就是默认的二个小时。

+ UDP中使用connect的好处:

1:会提升效率. 前面已经描述了. 
2:高并发服务中会增加系统稳定性. 原因:假设client A 通过非connect的UDP与serverB,C通信. B,C提供相同服务. 为了负载均衡,我们让A与B,C交替通信. A 与 B通信IPa:PORTa<----> IPb:PORTbA 与 C通信IPa:PORTa'<---->IPc:PORTc
假设PORTa 与 PORTa'相同了(在大并发情况下会发生这种情况),那么就有可能出现A等待B的报文,却收到了C的报文. 导致收报错误. 解决方法内就是采用connect的UDP通信方式. 在A中创建两个udp,然后分别connect到B,C.

### 长连接和短连接


一致性哈希负载均衡，

### 描述在浏览器中敲入一个网址并按下回车后所发生的事情


1. 语法解析网址，如果你的网址不合法则抛异常，比如 
你录入 http://www.baidu.com 浏览器就调用http协议 
录入 ftp://ftp.tsinghua.edu.cn 浏览器就调用ftp协议
录入浏览器不识别的协议则报错

以下只针对http协议

2. 查询cache
网址被分段解析后，浏览器首先在本地缓存查询cache，如果cache被标明是最新的则直接使用缓存内容。

3. DNS解析（可选）
向dns缓存服务(DNS client)或服务器查询域名对应的ip

4. 连接服务器（可选）
tcp/ip 握手连接服务器，如果已经有了被保持的连接，则复用此连接（Connection: Keep-Alive）

5. 发送http请求
向指定ip发送请求，具体http header定义查看 rfc文档
例如如果本地有cache但不能确定是否是最新的cache则发送
If-Modified-Since 和 If-None-Match 头

6. 接收服务器响应
如果服务器响应为重定向（301或302）则浏览器必须取响应的Location ，然后重复1-6步骤。
如果服务器响应为304，则浏览器使用本地cache
如果响应为200，则接收具体的数据。

7. 断开同服务器的连接（可选）
如果服务器响应为Connection: Keep-Alive，则需要保持连接，备后继http使用

8. 写cache
将可以缓存的内容保存到cache
