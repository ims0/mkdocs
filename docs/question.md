
## 后台题目

### 操作系统
#### 1. 谈谈你对内核态的理解，操作系统什么时候会陷入内核态，如何避免

1.进行系统调用的时候。比如创建文件，操作系统要读写磁盘
2.硬件中断发生的时候。比如按下键盘，操作系统要读取按键
3.发生异常的时候。比如缺页异常，操作系统要分配物理内存给应用程序

#### 2. [什么是内核线程](https://www.cnblogs.com/alantu2018/p/8526916.html)

内核线程是直接由内核本身启动的进程。内核线程实际上是将内核函数委托给独立的进程，它与内核中的其他进程”并行”执行。内核线程经常被称之为内核守护进程。
内核线程由内核自身生成，其特点在于
它们在CPU的管态执行，而不是用户态。
它们只可以访问虚拟地址空间的内核部分（高于TASK_SIZE的所有地址），但不能访问用户空间

#### 3. fork()函数族和clone()函数族的区别，什么是写时复制，为什么要用这种方式
clone函数功能强大，带了众多参数，因此由他创建的进程要比前面fork,vfork种方法要复杂，而fork与vfork都是无参数的，即共享那些资源早已规定。
clone可以让你有选择性的继承父进程的资源，你可以选择想vfork一样和父进程共享一个虚存空间，从而使创造的是线程，你也可以不和父进程共享，你甚至可以选择创造出来的进程和父进程不再是父子关系，而是兄弟关系。
#### 4. exec()和fork()的区别
fork 函数我们知道fork出来的进程几乎是完全一样的，这感觉并没有什么用，所以我们想着使用这个新的进程去干点大事，例如运行一个别的程序 A ，一旦系统调用 exec() 函数族的函数，那么当前进程（也就是和父进程一样的进程）就死掉了，不再执行 exec() 后面的代码，即这个创建出来的进程就被进程 A 给替换了，系统重新分配资源，只留下进程号pid。
#### 5. 常用linux指令，查看端口情况，网络情况，内存情况的指令
lsof,netstat,
traceroute命令可以用来查看数据包在主机到目的主机之间传输时，经过路由器的信息。
free

#### 6. linux有两种实时调度策略，谈谈你对它们的理解
#### 7. linux提供了哪些同步方法
多线程涉及的4个主要领域

1. 消息传递（管道，FIFO，消息队列）
2. 同步（互斥锁，条件变量，读写锁，信号量）
3. 共享内存区
4. 过程调用（Solaris 门， Sun RPC）
#### 8. 谈谈对linux中信号量的理解

### 网络
#### 1. 如何判断一个你打向的ip在国内还是国外，用什么工具？
使用IP库判断IP地址
#### 2. 判断你的请求数据包被转发了几次，路径是什么，用什么工具？
nginx
traceroute命令可以用来查看数据包在主机到目的主机之间传输时，经过路由器的信息。
#### 3. Http状态码 205、401、403、503是什么

+ 205 Reset Content
服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。
与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。
+ 401 Unauthorized
当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。
+ 403 Forbidden
服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。
+ 404 Not Found
请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。
+ 503 Service Unavailable
由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。


#### 4. 内部接口互相调用，如果要增加鉴权，鉴权是放在header里还是body里，为什么
#### 5. 外部接口调用，如果要有防重放的攻击检测，如何保证安全性
#### 6. tcp为什么要四次挥手，为什么不是三次
#### 7. http1.0和1.1的区别 1.1和2的最大区别
https://juejin.im/entry/5981c5df518825359a2b9476
HTTP1.0和HTTP1.1的一些区别

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

+ **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

+ **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

+ **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

+ **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

+ **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

HTTP2.0和HTTP1.X相比的新特性

+ **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

+ **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

+ **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

+ **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。 
#### 8. ssl和https
HTTP 是一个网络协议，是专门用来帮你传输 Web，ssl中文叫安全套接层为了结局传输内容会被偷窥（嗅探）和篡改，https是 “HTTP 协议”和“SSL/TLS 协议”的组合。
#### 9. 洪水攻击原理
https://zhuanlan.zhihu.com/p/78831197


TCP有哪些字段：

1、ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。

2、SYN 同步序列号，TCP建立连接时将这个位置1。

3、FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。

Socket建立网络连接的步骤：服务器监听、客户端请求、连接确认
————————————————
原文链接：https://blog.csdn.net/qq_27262727/article/details/104905248

### 数据结构
#### 1. 什么是堆，什么场景下用堆
#### 2. 你有看过什么语言下的数据结构相关的sdk源码，有看过STL中的吗（C++问题就不列举了）
#### 3. 有实现过某种二叉平衡树吗，难点在哪里，红黑树呢
#### 4. map为什么能o(1)时间复杂度完成set/get操作，hashMap扩容如何保证在新的map里hash取到原来的值，并且这种hash是公平的

### 组成原理
#### 1. [cpu栈寄存器 指针寄存器](https://www.cnblogs.com/Rebel3/p/11508867.html)
ESP
Stack Pointer 堆栈指针寄存器，该指针用于存储堆栈存储器数据
EBP
Base Pointer 基址指针寄存器，该指针用于存放堆栈段的数据区的“基地址”
#### 2. smp对称多处理器 是如何在总线上实现信号的同步，如何实现各个cpu中缓存行的一致性
#### 3. 有研究过x86吗
#### 4. l1 l2 l3 cache

### 算法
#### 1. 给n个人 再给n个人的朋友关系 1-2这种表示1和2是朋友 2和1也是朋友，再给一个int k，问能否把这n个人分成k组，每组的人彼此都不是朋友，如果能，输出这种结果
#### 
#### 2. excel里的列数如下 A,B,C…Z…AA,AB,AC…AZ,BA…AAA…给你一个字符串 问它是excel里的多少列 如AB就是28列
#### 
#### 3. 一个正整数k 问有没有一个所有位数都是1的数字，正好整除这个k，如果有，返回所有合法数中最小的那个的的位数，没有返回-1，如给你3，那么111是合法数中最小的，返回3
