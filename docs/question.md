
## 后台题目

### 操作系统
#### 1. 谈谈你对内核态的理解，操作系统什么时候会陷入内核态，如何避免

1.进行系统调用的时候。比如创建文件，操作系统要读写磁盘
2.硬件中断发生的时候。比如按下键盘，操作系统要读取按键
3.发生异常的时候。比如缺页异常，操作系统要分配物理内存给应用程序

#### 2. [什么是内核线程](https://www.cnblogs.com/alantu2018/p/8526916.html)

内核线程是直接由内核本身启动的进程。内核线程实际上是将内核函数委托给独立的进程，它与内核中的其他进程”并行”执行。内核线程经常被称之为内核守护进程。
内核线程由内核自身生成，其特点在于
它们在CPU的管态执行，而不是用户态。
它们只可以访问虚拟地址空间的内核部分（高于TASK_SIZE的所有地址），但不能访问用户空间

#### 3. fork()函数族和clone()函数族的区别，什么是写时复制，为什么要用这种方式
clone函数功能强大，带了众多参数，因此由他创建的进程要比前面fork,vfork种方法要复杂，而fork与vfork都是无参数的，即共享那些资源早已规定。
clone可以让你有选择性的继承父进程的资源，你可以选择想vfork一样和父进程共享一个虚存空间，从而使创造的是线程，你也可以不和父进程共享，你甚至可以选择创造出来的进程和父进程不再是父子关系，而是兄弟关系。
#### 4. exec()和fork()的区别
fork 函数我们知道fork出来的进程几乎是完全一样的，这感觉并没有什么用，所以我们想着使用这个新的进程去干点大事，例如运行一个别的程序 A ，一旦系统调用 exec() 函数族的函数，那么当前进程（也就是和父进程一样的进程）就死掉了，不再执行 exec() 后面的代码，即这个创建出来的进程就被进程 A 给替换了，系统重新分配资源，只留下进程号pid。

#### 6. linux有两种实时调度策略，谈谈你对它们的理解
#### 7. 谈谈对linux中信号量的理解

### 网络
#### 1. 如何判断一个你打向的ip在国内还是国外，用什么工具？
使用IP库判断IP地址
#### 2. 判断你的请求数据包被转发了几次，路径是什么，用什么工具？
traceroute命令可以用来查看数据包在主机到目的主机之间传输时，经过路由器的信息。

#### 4. 内部接口互相调用，如果要增加鉴权，鉴权是放在header里还是body里，为什么
#### 5. 外部接口调用，如果要有防重放的攻击检测，如何保证安全性
[如何防止重放攻击](https://blog.csdn.net/weixin_39986856/article/details/82657808)

#### 6. http1.0和1.1的区别 1.1和2的最大区别
https://juejin.im/entry/5981c5df518825359a2b9476
HTTP1.0和HTTP1.1的一些区别

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

+ **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

+ **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

+ **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

+ **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

+ **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

HTTP2.0和HTTP1.X相比的新特性

+ **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

+ **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

+ **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

+ **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。 
#### 8. ssl和https
HTTP 是一个网络协议，是专门用来帮你传输 Web，ssl中文叫安全套接层为了结局传输内容会被偷窥（嗅探）和篡改，https是 “HTTP 协议”和“SSL/TLS 协议”的组合。
#### 9. 洪水攻击原理
https://zhuanlan.zhihu.com/p/78831197


TCP有哪些字段：

1、ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。

2、SYN 同步序列号，TCP建立连接时将这个位置1。

3、FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。

Socket建立网络连接的步骤：服务器监听、客户端请求、连接确认
————————————————
原文链接：https://blog.csdn.net/qq_27262727/article/details/104905248

### 数据结构
#### 1. 什么是堆，什么场景下用堆
#### 2. 你有看过什么语言下的数据结构相关的sdk源码，有看过STL中的吗（C++问题就不列举了）
#### 3. 有实现过某种二叉平衡树吗，难点在哪里，红黑树呢
#### 4. map为什么能o(1)时间复杂度完成set/get操作，hashMap扩容如何保证在新的map里hash取到原来的值(一致性哈希)，并且这种hash是公平的

### 组成原理
#### 1. [cpu栈寄存器 指针寄存器](https://www.cnblogs.com/Rebel3/p/11508867.html)
ESP
Stack Pointer 堆栈指针寄存器，该指针用于存储堆栈存储器数据
EBP
Base Pointer 基址指针寄存器，该指针用于存放堆栈段的数据区的“基地址”
#### 2. smp对称多处理器 是如何在总线上实现信号的同步，如何实现各个cpu中缓存行的一致性
#### 3. 有研究过x86吗
#### 4. l1 l2 l3 cache

### 算法
#### 1. 给n个人 再给n个人的朋友关系 1-2这种表示1和2是朋友 2和1也是朋友，再给一个int k，问能否把这n个人分成k组，每组的人彼此都不是朋友，如果能，输出这种结果
#### 
#### 2. excel里的列数如下 A,B,C…Z…AA,AB,AC…AZ,BA…AAA…给你一个字符串 问它是excel里的多少列 如AB就是28列
#### 
#### 3. 一个正整数k 问有没有一个所有位数都是1的数字，正好整除这个k，如果有，返回所有合法数中最小的那个的的位数，没有返回-1，如给你3，那么111是合法数中最小的，返回3
