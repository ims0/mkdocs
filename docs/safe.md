
## Https

+ HTTP： 直接通过明文在浏览器和服务器之间传递信息。
+ HTTPS： 采用 对称加密 和 非对称加密 结合的方式来保护浏览器和服务端之间的通信安全。

1. 对称加密算法使用起来简单快捷，密钥较短，且破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比DES的加密性好，而且对计算机功能要求也没有那么高。IDEA加密标准由PGP（Pretty Good Privacy）系统使用。 常见的对称加密算法有DES、3DES、Blowfish、IDEA、RC4、RC5、RC6和AES 

2. 非对称加密算法, [RSA原理--阮一峰](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)

![avatar](http_pic/https_proc.webp)

### CA 证书的签发与校验 
![avatar](http_pic/CA-cert.png)

#### CA 签发证书的过程，如上图左边部分：
首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；
然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；
最后将 Certificate Signature 添加在文件证书上，形成数字证书；
#### 客户端校验服务端的数字证书的过程，如上图右边部分：
首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；
最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。


### 为什么数据传输是用对称加密？
首先：非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。
另外：在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。

## cookie session token

### session & token

1. Cookie特点：

cookie是将数据保存在浏览器端，是一门浏览器端的技术。由于数据保存在浏览器端，所以可以被任意的查看，安全性较低，但是可以长时间存储数据。cookie善于存储安全性要求较低，但是存储时间较长的数据。

2. Session特点：

session是将数据保存在服务器端，是一门服务器端的技术，数据保存在服务器端相对安全，但是服务器无法保留大量session对象，所以不能够长时间存储数据。服务器善于存储安全性要求较高，但是存储时间较短的数据。

3. 抛弃session，引入Token。

比如说， 用户F通过浏览器已经登录了系统， 服务器给他发一个令牌(token)， 里边包含了用户F的 user id， 下一次用户F再次通过Http 请求访问服务器的时候， 把这个token 通过Http header 带过来，服务器拿到这个user id，就认为它已经登录了系统。但是任何人都可以伪造这个token中的user id， 所以得想点儿办法， 让别人伪造不了。

那就对数据user id做一个签名吧， 比如说用HMAC-SHA256 算法，加上一个只有服务器才知道的密钥， 对数据做一个签名， 把这个签名和数据一起作为token 返回给浏览器， 由于密钥只有服务器知道， 别人就无法伪造token了。

这个token 服务器不保存， 当浏览器把这个token 给服务器发过来的时候，服务器再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名， 和token 中的签名做个比较；如果相同， 服务器就认为在该浏览器发送请求的用户已经登录过了，并且可以直接取到用户F的user id ； 如果不相同， 数据部分肯定被人篡改过， 服务器就告诉发送者：对不起，没有认证。这样一来， 服务器就不保存session了， 只负责生成token , 然后验证token ， 用服务器的CPU计算时间获取了服务器的session 存储空间 ！

解除了session这个负担， 可以说是无事一身轻；机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。

注意：
Token 中的数据是明文保存的（虽然我会用Base64做下编码， 但那不是加密）， 还是可以被别人看到的， 所以我不能在其中保存像密码这样的敏感信息。

当然， 如果一个人的token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的session id 被别人偷走是一样的。

## 重放攻击

### 规避方法
1. 加随机数。该方法优点是认证双方不需要时间同步，双方记住使用过的随机数，如发现报文中有以前使用过的随机数，就认为是重放攻击。缺点是需要额外保存使用过的随机数，若记录的时间段较长，则保存和查询的开销较大。 [4] 
2. 加时间戳。该方法优点是不用额外保存其他信息。缺点是认证双方需要准确的时间同步，同步越好，受攻击的可能性就越小。但当系统很庞大，跨越的区域较广时，要做到精确的时间同步并不是很容易。 [4] 
3. 加流水号。就是双方在报文中添加一个逐步递增的整数，只要接收到一个不连续的流水号报文(太大或太小)，就认定有重放威胁。该方法优点是不需要时间同步，保存的信息量比随机数方式小。缺点是一旦攻击者对报文解密成功，就可以获得流水号，从而每次将流水号递增欺骗认证端。 [4] 

在实际中，常将方法(1)和方法(2)组合使用，这样就只需保存某个很短时间段内的所有随机数，而且时间戳的同步也不需要太精确。 [4] 
对付重放攻击除了使用本以上方法外，还可以使用挑战一应答机制和一次性口令机制，而且似乎后面两种方法在实际中使用得更广泛。 [4] 


## [CSRF,Cross-site Request Forgery](https://medium.com/@charithra/introduction-to-csrf-a329badfca49)

### 步骤
执行跨站请求伪造 (CSRF) 攻击有两个主要部分
* 1)第一部分是诱骗受害者点击链接或加载页面。这通常是通过社会工程完成的。通过使用社会工程方法，攻击者会引诱用户点击链接。
* 2)第二部分是向受害者的浏览器发送“伪造”或编造的请求。此链接将向 Web 应用程序发送看似合法的请求。该请求将与攻击者想要的值一起发送。除此之外，此请求将包括受害者与该网站相关联的任何 cookie。

### 防范

#### Anti-CSRF Tokens

防止跨站点请求伪造 (CSRF) 的最流行的实现是利用与特定用户相关联的token，这个token做为隐藏字段存在于每个修改状态的表单中，此令牌称为CSRF令牌或同步器令牌，其工作方式如下：

1. 客户端请求包含表单的 HTML 页面。
1. 服务器在响应中包含两个令牌。一个令牌作为 cookie 发送。另一个放置在隐藏的表单域中。令牌是随机生成的，因此对手无法猜测这些值。
1. 当客户端提交表单时，它必须将两个令牌发送回服务器。客户端将 cookie 令牌作为 cookie 发送，并将表单令牌放在表单数据中发送。（当用户提交表单时，浏览器客户端会自动执行此操作。）
1. 如果请求不包含这两个令牌，则服务器不允许该请求。

#### Same Site Cookies
起源： 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。

含义：
```
协议相同
域名相同
端口相同
```

二.  Cookie跨域
Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。   
两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共享 Cookie
```
例如：

A 网页地址为 http://A1.example.com
B 网页地址为 http://B1.example.com

A 网页与B网页 一级域名相同，二级域名不同，所以可以通过设置document.domain='example.com';
来实现跨域访问cookie

在A页面存在
document.cookie="cookieName=cookieValue";

那么在B页面可以通过
val allCookie=document.cookie获取到A网页保存的cookie
```


## [XSS Cross-Site Scripting](https://medium.com/@charithra/introduction-to-xss-e9eb90b4323d)

介绍
跨站点脚本攻击是攻击者将恶意代码（通常是客户端脚本）注入 Web 应用程序的攻击。由于可能的注入位置和技术的数量众多，许多应用程序容易受到这种攻击方法的影响。这些类型的攻击与其他 Web 应用程序漏洞不同，因为它们攻击的是应用程序的用户，而不是应用程序的基础设施，但它们仍然会造成很大的破坏。XSS攻击涉及以下三方

* 攻击者
* 受害者
* 攻击者用来对受害者采取行动的易受攻击的网站。
