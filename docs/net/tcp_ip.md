# 

## [TCP/IP详解 卷1：协议](http://www.52im.net/topic-tcpipvol1.html?mobile=no)

### IP服务的特点
  IP协议是TCP/IP协议族的动力，他为上层协议提供无状态、无连接、不可靠的服务。
#### 无状态：
  是指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接受都是相互独立的、没有上下文关系的。
+ 缺点是无法处理乱序的和重复的IP数据报。接收端只负责将其数据部分交给上层协议，比如TCP协议，由它处理乱序的、重复的数据。
虽然IP数据报头部提供了一个标识字段用以唯一标识一个IP数据报，但它是被用来处理IP分片和重组的，而不是用来指示接收顺序的。
+ 优点是简单高效。无需为保持通信状态分配内核资源，也无需每次传输数据时都携带状态信息。
#### 无连接：
  是指IP通信双方都不长久地维持对方的任何信息。所以上层协议发送数据时，都必须明确指定对方的IP地址。
#### 不可靠：
  是指IP协议不能保证IP数据报准确地到达接受端，他只是承诺尽最大努力。就是说，发生任何意外导致IP数据报发送失败，它就通知上层协议发送失败，因此，使用IP服务的上层协议需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。


### IPv4头部结构
长度通常为20字节，除非有可变长的选项部分

![avatar](tcp_ip_pic/ip.jpg)
横着一行为32个bit，为四个字节。

+ **4位版本号** 指定IP协议的版本。对IPv4来说，为4。

+ **4位头部长度** 标识该IP头部有多少个32bit(即多少行),四位最大表示15，所以IP头部最长为60字节。

+ **8位服务类型** 包括一个三位的优先权字段(现在已忽略)四位的TOS字段和一位保留字段(保留需置0).四位的TOS字段分别表示：最小延时，最大吞吐量，最高可靠性和最小费用。这四位中最多只有一位置1。应用程序根据需要设置(比如ssh需要最小延时，ftp需要最大吞吐量)。

+ **16位总长度** 是指整个IP数据报的长度，以字节为单位，因此IP数据报最大长度为65535-1字节。但由于MTU的限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP数据报的长度都远远没有达到最大值。

+ **16位标识：** 唯一地标识主机发送的每一个数据报。其初始值由系统随机生成，每发送一个数据报，其值就加一。该值在数据报分片时被复制到每个分片中，因此同一个数据报的所有分片都具有相同的标识符。

+ **3位标志字段：** 第一位保留。第二位标识禁止分片。设置后，IP将不对该数据报分片，当该数据报长度超过MTU时，IP模块将丢弃该数据包并返回一个ICMP差错报文。第三位表示更多分片。除了数据报的最后一个分片外，其他分片都要把该位置1.

+ **13位分片偏移** 是分片相对原始IP数据报开始处(仅指数据部分)的偏移。实际的偏移值是该值左移三位(乘8)后得到的。因此，每个IP分片的数据部分的长度必须是8的整数倍。

+ **8位生存时间TTL(time to live)：** 是数据报到达目的地之前允许经过的路由器跳数。发送端设置(通常是64)。数据报每经过一次路由，该值就被路由器减一，为零时，路由器将丢弃该数据报，并向源端发送一个ICMP差错报文。TTL可以防止数据报陷入路由循环。

+ **8位协议：** 用来区分上层协议。/etc/protocols文件定义了所有上层协议对应的字段的数值。例如，ICMP是1，TCP是6，UDP是17。

+ **16位头部校验和：** 由发送端填充，接收端对其使用CRC算法检验头部在数据传输过程中是否损坏。

+ **32位源端IP地址：** 用来表示IP数据报的发送端

+ **32位目的端IP地址：** 用来表示IP数据报的接收端

+ **选项字段：** 是可变长的可选信息。最多包含40字节，可用的选项有：

记录路由：将途径的路由器的ip地址填入选项部分，用于跟踪数据报的传递路径。时间戳：告诉每个路由器将数据报被转发的时间(或时间与IP地址对)填入IP头部的选项部分，这样就可以测量途径路由之间数据报传输的时间。

松散路由选择：指定路由IP地址列表，数据包发送过程必须经过其中所有路由器。

严格路由选择：数据报只能经过被指定的路由器。


原文链接：https://blog.csdn.net/weixin_44135544/article/details/103162399

---
## UDP 协议

###  udp 8字节头结构

udp头比tcp多了报文长度字段，tcp的报文长度有ip头指定

![avatar](tcp_ip_pic/udp_head.jpg)

![avatar](tcp_ip_pic/udp_ip.jpg)

### UDP 报文长度

在普通的局域网环境下，我建议将UDP的数据控制在1472字节以下为好。

进行Internet编程时则不同，因为Internet上的路由器可能会将MTU设为不同的值。如果我们假定MTU为1500来发送数据的，而途经的某个网络的MTU值小于1500字节，那么系统将会使用一系列的机制来调整MTU值，使数据报能够顺利到达目的地，这样就会做许多不必要的操作。

鉴于Internet上的标准MTU值为576字节，所以我建议在进行Internet的UDP编程时，最好将UDP数据的长度控制在548字节（576-8-20）以内。

---


## TCP 协议部分
### 1. TCP头部分析与确认号的理解
![avatar](tcp_ip_pic/tcp_header_en.jpg)
![avatar](tcp_ip_pic/tcp_ch.png)

+ **源端口号和目的端口号**：再加上Ip首部的源IP地址和目的IP地址可以唯一确定一个TCP连接
+ **数据序号**：表示在这个报文段中的第一个数据字节序号
+ **确认序号**：仅当ACK标志为1时有效。确认号表示期望收到的下一个字节的序号（这个下面再详细分析）
+ **偏移**：就是头部长度，有4位，跟IP头部一样，以4字节为单位。最大是60个字节
+ **保留位**：6位，必须为0
+ 6个标志位：
1. URG-紧急指针有效
2. ACK-确认序号有效
3. PSH-接收方应尽快将这个报文交给应用层
4. RST-连接重置
5. SYN-同步序号用来发起一个连接
6. FIN-终止一个连接

+ **窗口字段**：16位，代表的是窗口的字节容量，也就是TCP的标准窗口最大为2^16 - 1 = 65535个字节

+ **校验和**：源机器基于数据内容计算一个数值，收信息机要与源机器数值 结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。

+ **紧急指针**：是一个正偏移量，与序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式
+ **选项与填充**（必须为4字节整数倍，不够补0）：
最常见的可选字段的最长报文大小MSS（Maximum Segment Size），每个连接方通常都在一个报文段中指明这个选项。它指明本端所能接收的最大长度的报文段。
该选项如果不设置，默认为536（20+20+536=576字节的IP数据报）

### 2.TCP如何保证可靠性

* 1）应用数据被分割成TCP认为最合适发送的数据块。称为段（Segment）传递给IP层
* 2）当TCP发出一个段后，它会启动一个定时器，等待目的端确认收到这个报文段。若没有及时收到确认，将重新发送这个报文段
* 3）当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送的，通常将推迟200ms。
* 4）TCP将保持它首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的校验和有差错，TCP将丢弃这个报文也不进行确认（对方就会重复发送了）。
* 5）TCP承载与IP数据报来传输，而IP数据报可能会失序，所以TCP的报文段到达时也可能会失序。但是TCP收到数据后会重新排序到正确的顺序（通过序号）。
* 6）IP数据报会发生重复，TCP的接收端必须丢弃重复是数据
* 7）TCP还能提供流量控制，TCP连接的每一方都有一定大小的缓冲空间

### ACK延迟确认机制
接收方在收到数据后，并不会立即回复ACK,而是延迟一定时间。一般ACK延迟发送的时间为200ms，但这个200ms并非收到数据后需要延迟的时间。系统有一个固定的定时器每隔200ms会来检查是否需要发送ACK包。
这样做有两个目的:

1. 这样做的目的是ACK是可以合并的，也就是指如果连续收到两个TCP包，并不一定需要ACK两次，只要回复最终的ACK就可以了，可以降低网络流量。
2. 如果接收方有数据要发送，那么就会在发送数据的TCP数据包里，带上ACK信息。这样做，可以避免大量的ACK以一个单独的TCP包发送，减少了网络流量。

### [TCP 四个计时器](https://blog.csdn.net/qq_33951180/article/details/60468267)

TCP中的四个计时器包括重传计时器、坚持计时器、保活计时器、时间等待计时器

#### 1. 重传计时器(Retransmission Timer)：

目的：为了控制丢失的报文段或者丢弃的报文段。这段时间为对报文段的等待确认时间。
#### 2.  坚持计时器(Persistent Timer)：

目的：主要解决零窗口大小通知可能导致的死锁问题

#### 3. 保活计时器(Keeplive Timer)：
+ tcp心跳包计时器，解决半打开连接问题。
+ 目的：主要是为了防止两个TCP连接出现长时间的空闲。当客户端与服务器端建立TCP连接后，很长时间内客户端都没有向服务器端发送数据，此时很有可能是客户端出现故障，而服务器端会一直处于等待状态。保活计时器就是解决这种问题而生的。

#### 4. 时间等待计时器(Time_Wait Timer)：

时间等待计时器是在连接终止期间使用的。

### [TCP的半关闭 与rsh](http://docs.52im.net/extend/docs/book/tcpip/vol1/18/)

TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的半关闭。
为了使用这个特性，编程接口必须为应用程序提供一种方式来说明“我已经完成了数据传送，因此发送一个文件结束（FIN）给另一端，但我还想接收另一端发来的数据，直到它给我发来文件结束（FIN）”.

命令
`sun % rsh bsdi sort < datafile`

+ 没有半关闭，需要其他的一些技术让客户通知服务器,客户端已经完成了它的数据传送，但仍要接收来自服务器的数据。



-------------
### 3. 滑动窗口协议（也就是对包头中窗口字段的理解）
[book](http://docs.52im.net/extend/docs/book/tcpip/vol1/19/)

[TCP拥塞控制-慢启动、拥塞避免、快重传、快启动](https://blog.csdn.net/jtracydy/article/details/52366461)

参考1：https://www.cnblogs.com/ulihj/archive/2011/01/06/1927613.html

参考2：http://blog.chinaunix.net/uid-26275986-id-4109679.html

#### 拥塞避免算法
![avtor](tcp_ip_pic/yongsaibimian.png)

拥塞避免：指数增长，加法增加，乘法减小。
#### 快重传与快恢复

![avtor](tcp_ip_pic/quick-huifu.png)
当收到第3个重复的ACK时，将ssthresh设置为当前拥塞窗口cwnd的一半。重传丢失的报文段。设置cwnd为ssthresh加上3倍的报文段大小。
每次收到另一个重复的ACK时，cwnd增加1个报文段大小并发送1个分组（如果新的cwnd允许发送）。
当下一个确认新数据的ACK到达时，设置cwnd为ssthresh（在第1步中设置的值）。这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认。另外，这个ACK也应该是对丢失的分组和收到的第1个重复的ACK之间的所有中间报文段的确认。这一步采用的是拥塞避免，因为当分组丢失时我们将当前的速率减半。


先上两个概念：
通告接收窗口（rwnd）：预防应用程序发送的数据超过对方的缓冲区，接收方使用的流量控制。
拥塞窗口（cwnd）：预防应用程序发送的数据超过了网络所能承载的能力。发送方使用的流量控制。
发送窗口：就是指上面两者的较小值

由于TCP的全双工的，所以其实TCP双方各自都维护一个发送窗口和接收窗口。

假设是主机A发送给主机B
A和B都会维护一个数据帧的序列，这个序列称为窗口。发送方的窗口大小由接收方确定。目的在于控制发送速度。以免接收方的缓存不够大而导致溢出，同时流量控制也可以避免网络拥塞。
这里其实是指A的发送窗口。

![avatar](tcp_ip_pic/tcp_window.png)

### 4. keepalive 用途
+ TCP的keepalive是侧重在保持客户端和服务端的连接，一方会不定期发送心跳包给另一方，当一方端掉的时候，没有断掉的定时发送几次心跳包，如果间隔发送几次，对方都返回的是RST，而不是ACK，那么就释放当前链接。设想一下，如果tcp层没有keepalive的机制，一旦一方断开连接却没有发送FIN给另外一方的话，那么另外一方会一直以为这个连接还是存活的，几天，几月。那么这对服务器资源的影响是很大的。

+ HTTP的keep-alive一般我们都会带上中间的横杠，普通的http连接是客户端连接上服务端，然后结束请求后，由客户端或者服务端进行http连接的关闭。下次再发送请求的时候，客户端再发起一个连接，传送数据，关闭连接。这么个流程反复。但是一旦客户端发送connection:keep-alive头给服务端，且服务端也接受这个keep-alive的话，两边对上暗号，这个连接就可以复用了，一个http处理完之后，另外一个http数据直接从这个连接走了。减少新建和断开TCP连接的消耗。

作者：Katou_Megumi
链接：https://www.jianshu.com/p/9fe2c140fa52
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


### 5.关于包头中确认号ack的理解

确认序号：仅当ACK标志为1时有效。确认号表示期望收到的下一个字节的序号
经受时延的确认（Delay ACK）:http://www.vants.org/?post=114

### 传输数据的简要过程如下：

* 1）发送数据：服务器向客户端发送一个带有数据的数据包。该数据包中的序列号和确认号与建立连接第三步的数据包找那个的序列号和确认号相同。
* 2）确认收到：客户端收到该数据包，向服务器发送一个确认数据包。该数据包中，序列号是为上一个数据包中的确认号值。
而确认号为服务器发送的上一个数据包中的序列号+该数据包中所带数据的大小。回复确认收到的ack = 收到了序列号 + 数据的大小（同时也表示下一次期望收到的序号）


### nc 测试交互过程的sn、ack 变化

服务端监听本地端口3000

`nc -lv localhost 3000`

客户端连接本地端口 3000

`nc -v localhost 3000`

tcpdump 查看交互消息

`tcpdump -pnv -i lo port 3000`

+ [三次握手与三次挥手的交互](tcp_ip_pic/tcp_ip_interactive.pcap)

![avatar](tcp_ip_pic/tcp_ip_interactive.JPG)

### time_wait 产生的原因

如下图所示：主动关闭的那端 在发送ACK后会经历这个状态，该状态持续时间是最长分节生命期(maximum segment lifetime, MSL)的两倍，也称2MSL

![avatar](tcp_ip_pic/net_state_conv.png)

#### 主动关闭方经历的状态有:
1. `FIN_WAIT_1 --> TIME_WAIT ` :同时收到 FIN 与ACK
2. `FIN_WAIT_1 --> CLOSING --> TIME_WAIT` :先收到 ACK,后收到 FIN, 被动方应该是先发了FIN后发ACK. 
3. `FIN_WAIT_1 --> FIN_WAIT_2 --> TIME_WAIT` : 先收到ACK，后收到FIN

#### 被动关闭方经历的状态有:
1. `CLOSE_WAIT --> LAST_ACK --> CLOSED` 

#### time_wait 存在的两个理由：
1. 可靠的实现TCP全双工连接的终止。
2. 允许老的重复分节在网络中消逝。

详细解释：

1. 防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失，Linux可以`cat /proc/sys/net/ipv4/tcp_fin_timeout`看这个值默认60））
2. 可靠的关闭TCP连接 在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发 fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以 主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 

#### 让每个TIME_WAIT早点过期,在linux上可以这么配置：

+ 让 **TIME_WAIT** 尽快回收，我也不知是多久，观察大概是一秒钟
    `echo "1" > /proc/sys/net/ipv4/tcp_tw_recycle`
+ 让TIME_WAIT状态可以重用，这样即使TIME_WAIT占满了所有端口，也不会拒绝新的请求造成障碍
    `echo "1" > /proc/sys/net/ipv4/tcp_tw_reuse`

很多文档都会建议两个参数都配置上，但是我发现只用修改tcp_tw_recycle就可以解决问题的了，TIME_WAIT重用TCP协议本身就是不建议打开的。

不能重用端口可能会造成系统的某些服务无法启动，比如要重启一个系统监控的软件，它用了40000端口，而这个端口在软件重启过程中刚好被使用了，就可能会重启失败的。linux默认考虑到了这个问题，有这么个设定：

+ 查看系统本地可用端口极限值
    `cat /proc/sys/net/ipv4/ip_local_port_range`

用这条命令会返回两个数字，默认是：32768 61000，说明这台机器本地能向外连接61000-32768=28232个连接，注意是本地向外连接，不是这台机器的所有连接，不会影响这台机器的80端口的对外连接数。但这个数字会影响到代理服务器（nginx）对app服务器的最大连接数，因为nginx对app是用的异步传输，所以这个环节的连接速度很快，所以堆积的连接就很少。

### 什么情况下会有大量的time_wait

在**高并发短连接的TCP服务器**上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。

### 怎么避免大量的time_wait

查看time_wait数量
`netstat -ant|awk '/^tcp/ {++S[$NF]} END {for(a in S) print (a,S[a])}'`

#### 1.编辑内核文件/etc/sysctl.conf，加入以下内容：
```
net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间
```

然后执行 /sbin/sysctl -p 让参数生效.

/etc/sysctl.conf是一个允许改变正在运行中的Linux系统的接口，它包含一些TCP/IP堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。

简单来说，就是打开系统的TIMEWAIT**重用和快速回收**。

#### 2.如果以上配置调优后性能还不理想，可继续修改一下配置：
```
vi /etc/sysctl.conf
net.ipv4.tcp_keepalive_time = 1200 
#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。
net.ipv4.ip_local_port_range = 1024 65000 
#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。
net.ipv4.tcp_max_syn_backlog = 8192 
#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。
net.ipv4.tcp_max_tw_buckets = 5000 
#表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。
默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，
效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。

```

#### [tcp_tw_reuse、tcp_tw_recycle 使用场景及注意事项](https://www.cnblogs.com/lulu/p/4149312.html)
+ `tcp_tw_reuse 和 SO_REUSEADDR` 是两个完全不同的东西

SO_REUSEADDR 允许同时绑定 127.0.0.1 和 0.0.0.0 同一个端口； SO_RESUSEPORT linux 3.7才支持，用于绑定相同ip:port，像nginx 那样 fork方式也能实现

[tcp_tw_reuse - INTEGER](https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt)
```    
Enable reuse of TIME-WAIT sockets for new connections when it is
    safe from protocol viewpoint.
    0 - disable     1 - global enable     2 - enable for loopback traffic only
    It should not be changed without advice/request of technical experts.
    Default: 2
```
##### tcp_tw_reuse总结一下：
+ 1）tcp_tw_reuse选项和tcp_timestamps选项也必须同时打开；
+ 2）重用TIME_WAIT的条件是收到最后一个包后超过1s。

[tcp_tw_recycle](https://blog.csdn.net/yunhua_lee/article/details/8146845)

tcp_tw_recycle选项作用为：Enable fast recycling TIME-WAIT sockets. Default value is 0.
tcp_timestamps选项作用为：Enable timestamps as defined in RFC1323. Default value is 1.

+ 1.tcp_tw_recycle和tcp_timestamps两个选项都打开的时候才进行快速回收
+ 2.计算快速回收的时间，等于 RTO * 3.5，回答第一个问题的关键是RTO（Retransmission Timeout）
+ 3.RTO最大是120s，最小是200ms

##### tcp_tw_recycle总结一下：
+ 1）快速回收到底有多快？
局域网环境下，700ms就回收；
+ 2）有的资料说只要打开tcp_tw_recycle即可，有的又说要tcp_timestamps同时打开，具体是哪个正确？
需要同时打开，但默认情况下tcp_timestamps就是打开的，所以会有人说只要打开tcp_tw_recycle即可；
+ 3）为什么从虚拟机发起客户端连接时选项无效，非虚拟机连接就有效？
和网络组网有关系，无法获取对端信息时就不进行快速回收；
### 列举你所知道的tcp选项

1.窗口扩大因子TCP Window Scale Option (WSopt)

TCP窗口缩放选项是用来增加TCP接收窗口的大小而超过65536字节。

2.SACK选择确认选项

最大报文段长度（M S S）表示T C P传往另一端的最大块数据的长度。当建立一个连接时，每一方都有用于通告它期望接收的 M S S选项（M S S选项只能出现在S Y N报文段中）。通过MSS，应用数据被分割成TCP认为最适合发送的数据块，由TCP传递给IP的信息单位称为报文段或段(segment)。

TCP通信时，如果发送序列中间某个数据包丢失，TCP会通过重传最后确认的包开始的后续包，这样原先已经正确传输的包也可能重复发送，急剧降低了TCP性能。为改善这种情况，发展出SACK(SelectiveAcknowledgment, 选择性确认)技术，使TCP只重新发送丢失的包，不用发送后续所有的包，而且提供相应机制使接收方能告诉发送方哪些数据丢失，哪些数据重发了，哪些数据已经提前收到等。

3.MSS:Maxitum Segment Size 最大分段大小


## ICMP (Internet控制报文协议）

ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

### ICMP 应用(ping tracert)
ICMP 协议应用在许多网络管理命令中，下面以 ping 和 traceroute 命令为例。 

#### ping 命令
在网络可达性测试中使用的分组网间探测命令 ping 能产生 ICMP 回送请求和应答报文。目的主机收到 ICMP 回送请求报文后立刻回送应答报文，若源主机能收到 ICMP 回送应答报文，则说明到达该主机的网络正常。

#### traceroute 查路由

首先发送TTL为1的 UDP 报文，然后每次将TTL字段加1，路由器收到TTL为 0、1的报文后不转发直接丢弃，并给信源机发一份**ICMP超时信息**，如果是目的主机，就是TTL是1也不会丢弃，不过由于端口大于3000，会产生**端口不可达错误的ICMP**报文。

### ping 命令执行过程

#### 同一网段

1. ping通知系统建立一个固定格式的ICMP请求数据包

2. ICMP协议打包这个数据包和机器B的IP地址转交给IP协议层（一组后台运行的进程，与ICMP类似）

3. IP层协议将以机器B的IP地址为目的地址，本机IP地址为源地址，加上一些其他的控制信息，构建一个IP数据包

4. 获取机器B的MAC地址

+ IP层协议通过机器B的IP地址和自己的子网掩码，发现它跟自己属同一网络，就直接在本网络查找这台机器的MAC

+ 若两台机器之前有过通信，在机器A的ARP缓存表应该有B机IP与其MAC的映射关系

+ 若没有，则发送ARP请求广播，得到机器B的MAC地址，一并交给数据链路层

+ 数据链路层构建一个数据帧，目的地址是IP层传过来的MAC地址，源地址是本机的MAC地址，再附加一些控制信息，依据以太网的介质访问规则，将他们传送出去

+ 机器B收到这个数据帧后，先检查目的地址，和本机MAC地址对比

+ 符合，接收。接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP协议层协议。IP层检查后，将有用的信息提取交给ICMP协议，后者处理后，马上构建一个ICMP应答包，发送给主机A，其过程和主机A发送ICMP请求包到主机B类似（这时候主机B已经知道了主机A的MAC地址，不需再发ARP请求）

+ 不符合，丢弃

#### 不同网段

1. ping通知系统建立一个固定格式的ICMP请求数据包

2. ICMP协议打包这个数据包和机器B的IP地址转交给IP协议层（一组后台运行的进程，与ICMP类似）

3. IP层协议将以机器B的IP地址为目的地址，本机IP地址为源地址，加上一些其他的控制信息，构建一个IP数据包

4. 获取主机B的MAC地址

IP协议通过计算发现主机B与自己不在同一网段内，就直接交给路由处理，就是将路由的MAC取过来，至于怎么得到路由的MAC地址，和之前一样，先在ARP缓存表中寻找，找不到可以利用广播。路由得到这个数据帧之后，再跟主机B联系，若找不到，就向主机A返回一个**超时信息**。


#### 返回信息分析

1. Request timed out

+ 对方已关机，或者网络上没有这个地址
+ 对方与自己不在同一网段内，通过路由也无法到达
+ 对方存在，不过设置了ICMP数据包过滤（比如防火墙设置）
+ 错误设置IP地址

2. Destination host Unreachable

+ 自己未设定默认路由，对方跟自己不在同已网段
+ 网线有问题

3. Bad ip address

+ 没有连接到DNS服务器，无法解析IP，也可能是IP不存在

4. Source quench received

+ 对方或中途服务器繁忙而无法应答

5. Unkonw host

+ 远程主机的名字不能被域名服务器转换成IP地址，故障原因可能是DNS服务器有故障，或者名字不正确，或者网络管理员的系统与远程主机之间的通信线路故障。

6. No answer

+ 无响应。说明本地系统有一条通向中心主机的路由，但却接收不到它发给该中心主机的人呢和信息。故障原因可能是：中心主机没有工作；本地或中心主机网络配置不正确；本地或中心的路由器没有工作；通信线路有故障；中心主机存在路由选择问题。

7. Ping 127.0.0.1

+  如果ping不通，则表明本地址TCP/IP协议不能正常工作

8. no rout to host

+ 网卡工作不正常

9. transmit failed。error code

+  10043网卡驱动不正常

10. unknown host name

+ DNS配置不正确



## 网络问题汇总

[后台总结](https://www.cnblogs.com/liuzhi/p/4036840.html)

### tcp与udp的差异

 TCP是一种面向连接的、可靠的、字节流服务

1. 面向链接：TCP面向链接，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须通过三次握手先建立一个TCP连接。在一个TCP中仅有两方彼此通信，多播和广播不能用于TCP。UDP是不可靠的传输，传输前不需要建立链接，可以应用多播和广播实现一对多的通信。

2. 可靠性：TCP提供端到端的流量控制，对收到的数据进行确认，采用超时重发，对失序的数据进行重新排序等机制保证数据通信的可靠性。而UDP是一种不可靠的服务，接收方可能不能收到发送方的数据报。

3. TCP是一种流模式的协议，UDP是一种数据报模式的协议。进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。TCP应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系。TCP会有粘包和半包的现象。

4. 效率上：速度上，一般TCP速度慢，传输过程中需要对数据进行确认，超时重发，还要对数据进行排序。UDP没有这些机制所以速度快。数据比例，TCP头至少20个字节，UDP头8个字节，相对效率高。组装效率上：TCP头至少20个字节，UDP头8个字节，系统组装上TCP相对慢。

5. 用途上：用于TCP可靠性，http，ftp使用。而由于UDP速度快，视频，在线游戏多用UDP，保证实时性

对于第三点的理解。TCP可能发送100个“包”，而接收到50个“包”，不是丢“包”了，而是每次接受的“包”都比发送的多，其实TCP并没有包的概念。例如，每次发10个字节，可能读得时候一次读了20个字节。TCP是一种流模式的协议，在接收到的缓存中按照发送的包得顺序自动按照顺序拼接好，因为数据基本来自同一个主机，而且是按照顺序发送过来的，TCP的缓存中存放的就是，连续的数据。感觉好像是多封装了一步比UDP。而UDP因为可能两个不同的主机，给同一个主机发送，（一个端口可能收到多个应用程序的数据），或者按照TCP那样合并数据，必然会造成数据错误。我觉得关键的原因还是，TCP是面向连接，而UDP是无连接的，这就导致，TCP接收的数据为一个主机发来且有序无误的，而UDP可能是多个主机发来的无序，可能错误的。

---


### keepalive如何使用？

设置Keepalive参数，检测已中断的客户连接 在TCP中有一个Keep-alive的机制可以检测死连接，原理很简单，TCP会在空闲了一定时间后发送数据给对方：

1. 如果主机可达，对方就会响应ACK应答，就认为是存活的。
2. 如果可达，但应用程序退出，对方就发RST应答，发送TCP撤消连接。
3. 如果可达，但应用程序崩溃，对方就发FIN消息。
4. 如果对方主机不响应ack, rst，继续发送直到超时，就撤消连接。这个时间就是默认的二个小时。


### UDP中使用connect的好处:

1. 会提升效率. 前面已经描述了. 
2. 高并发服务中<font color="#0099ff">防止客户端端口重复</font>，增加系统稳定性. 

原因:假设client A 通过非connect的UDP与serverB,C通信. B,C提供相同服务.   
为了负载均衡,我们让A与B,C交替通信.   
A与B通信IPa:portA<----> IPb:PORTb  
A与C通信IPa:portA'<----> IPc:PORTc  
假设portA 与 portA'相同了(在大并发情况下会发生这种情况),   
那么就有可能出现A等待B的报文,却收到了C的报文. 导致收报错误.   
解决方法内就是采用connect的UDP通信方式. 在A中创建两个udp,然后分别connect到B,C.   

### 描述在浏览器中敲入一个网址并按下回车后所发生的事情
1. 语法解析网址，如果你的网址不合法则抛异常，比如 
你录入 http://www.baidu.com 浏览器就调用http协议 
录入 ftp://ftp.tsinghua.edu.cn 浏览器就调用ftp协议
录入浏览器不识别的协议则报错

以下只针对http协议

2. 查询cache
网址被分段解析后，浏览器首先在本地缓存查询cache，如果cache被标明是最新的则直接使用缓存内容。

3. DNS解析（可选）
向dns缓存服务(DNS client)或服务器查询域名对应的ip

4. 连接服务器（可选）
tcp/ip 握手连接服务器，如果已经有了被保持的连接，则复用此连接（Connection: Keep-Alive）

5. 发送http请求
向指定ip发送请求，具体http header定义查看 rfc文档
例如如果本地有cache但不能确定是否是最新的cache则发送
If-Modified-Since 和 If-None-Match 头

6. 接收服务器响应
如果服务器响应为重定向（301或302）则浏览器必须取响应的Location ，然后重复1-6步骤。
如果服务器响应为304，则浏览器使用本地cache
如果响应为200，则接收具体的数据。

7. 断开同服务器的连接（可选）
如果服务器响应为Connection: Keep-Alive，则需要保持连接，备后继http使用

8. 写cache
将可以缓存的内容保存到cache
