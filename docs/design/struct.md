## 二，结构型模式  
这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。

### 2.1 适配器模式（Adapter）
+ 意图  
将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

+ c++ 实现  
用公共方式继承接口，用私有方式继承接口的实现

+ 与Bridge模式对比  
Bridge 的目的是将接口与实现分离，从而比较容易的独立改变它们，而Adapter意味着改变一个已有对象的接口。


### 2.2 桥接模式（Bridge）
+ 意图  
将抽象部分与它的实现分离，使它们可以独立的改变。

+ c++ 实现  
接口类保存实现类的引用


### 2.3 组合模式（Composite）
### 2.4 装饰器模式（Decorator）
+ 意图  
动态的给一个对象添加额外的职责，就增加功能来说，Decorator 比生成子类更为灵活。

+ c++ 实现  
    1. 子类保存父类的引用，接口缺省调用父类的实现；
    2. 装饰的孙类重写父类的接口，在调用父类实现的同时增加自己的实现。`{dosomething(),Base::func()}`



### 2.5 外观模式（Facade）
### 2.6 享元模式（Flyweight）
### 2.7 代理模式（Proxy）
+ 意图  
为其他对象提供一种代理以控制对这个对象的访问。

+ eg:智能指针   
内存管理也是C++中的难点，而智能指针采用引用计数的办法很方便的帮我们管理了内存的使用，极大方便了我们的工作效率。而智能指针的这种用法其实就是代理模式的一种，他帮我们控制了该对象的内存使用。

