

## 五，[锁(innodb-locking doc)](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html)
[mysql lock video on bilibili](https://www.bilibili.com/video/BV1x54y1979n?from=search&seid=7051544205933286059)
### 死锁

#### lock & latch
0|lock  |latch
---| --- |  ---
对象 | 事务 | 线程
保护 | 数据库内容 |内存内容
持续时间|整个事务|临界资源
模式 |行锁，表锁，意向锁| 读写锁，互斥量
死锁 |通过等待图，超时机制检测 | 无检测，通过顺序加锁避免死锁
位置 |Lock Manager的哈希表中 |每个数据结构的对象中

#### 死锁检测
数据库普遍采用 wait-for graph等待图的方式来进行死锁检测。较等待超时方案更为主动，InnoDB引擎采用这个方式。
等待图根据锁与事物的关系构建图，如果出现回路，就代表死锁。
发生死锁时候，InnoDB选择回滚undo量最小的事务。


防止死锁的途径就是避免满足死锁条件的情况发生，适合这个问题解决的方案有:

1、保持事务简短并在一个批处理中
在同一数据库中并发执行多个需要长时间运行的事务时通常发生死锁。事务运行时间越长，其持有排它锁或更新锁的时间也就越长，从而堵塞了其它活动并可能导致死锁。保持事务在一个批处理中，可以最小化事务的网络通信往返量，减少完成事务可能的延迟并释放锁。

2、使用低隔离级别
确定事务是否能在更低的隔离级别上运行。执行提交读允许事务读取另一个事务已读取（未修改）的数据，而不必等待第一个事务完成。使用较低的隔离级别（例如提交读）而不使用较高的隔离级别（例如可串行读）可以缩短持有共享锁的时间，从而降低了锁定争夺（比如这次的S NK和X IK 是InnoDB引擎Repeatable Read级别才有的）。

* Shared and Exclusive Locks
* Intention Locks
* Record Locks
* Gap Locks
* Next-Key Locks
* Insert Intention Locks
* AUTO-INC Locks

Predicate Locks for Spatial Indexes
### 行级别锁
InnoDB 通过共享锁和排他锁两种方式实现了标准的行锁。

#### 共享锁(S 锁)：
允许事务获得锁后去读数据,如果写数据可能发生死锁。
想读数据，不允许别的事物修改数据, 类似读写锁的读锁。
```sql
LOCK IN SHARE MODE
```

####  排他锁(X 锁)：
允许事务获得锁后去更新或删除数据。    
是在数据库中上锁用的，可以为数据库中的行上一个排它锁。当一个事务的操作未完成时候，其他事务可以读取但是不能写入或更新。

* 自动加锁：增删改默认加锁
* 手动加锁：如下
```sql
for update
```

mysql 加锁语句
对于共享锁大家可能很好理解，就是多个事务只能读数据不能改数据，对于排他锁大家的理解可能就有些差别，我当初就犯了一个错误，以为排他锁锁住一行数据后，其他事务就不能读取和修改该行数据，其实不是这样的。排他锁指的是一个事务在一行数据加上排他锁后，其他事务不能再在其上加其他的锁。mysql InnoDB引擎默认的修改数据语句，update,delete,insert都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型，如果加排他锁可以使用select ...for update语句，加共享锁可以使用select ... lock in share mode语句。所以加过排他锁的数据行在其他事务种是不能修改数据的，也不能通过for update和lock in share mode锁的方式查询数据，但可以直接通过select ...from...查询数据，因为普通查询没有任何锁机制。

一个事务获取的共享锁(S)后，允许其他事务获取S锁，此时两个事务都持有共享锁(S)，但是不允许其他事务获取X锁。
如果一个事务获取的排他锁(X)，则不允许其他事务获取S或者X锁，必须等到该事务释放锁后才可以获取到。

```sql
# T1
START TRANSACTION WITH CONSISTENT SNAPSHOT;
SELECT * FROM category WHERE category_no = 2 lock in SHARE mode; //共享锁
SELECT * FROM category WHERE category_no = 2 for UPDATE; //排他锁
COMMIT;

# T2
START TRANSACTION WITH CONSISTENT SNAPSHOT;
SELECT * FROM category WHERE category_no = 2 lock in SHARE mode; //共享锁
UPDATE category set category_name = '动漫' WHERE category_no = 2; //排他锁
COMMIT;

```



### 行锁的三种算法


#### 记录锁(record Locks)
锁住某一行，如果表存在索引，那么记录锁是锁在索引上的，如果表没有索引，那么 InnoDB 会创建一个隐藏的聚簇索引加锁。
所以在进行查询的时候尽量采用索引进行查询，这样可以降低锁的冲突。
#### 间隙锁(Gap Locks)
间隙锁是一种记录行与记录行之间存在空隙或在第一行记录之前或最后一行记录之后产生的锁。间隙锁可能占据的单行，多行或者是空记录。
通常的情况是我们采用范围查找的时候，比如在学生成绩管理系统中，如果此时有学生成绩 60，72，80，95，一个老师要查下成绩大于 72 的所有同学的信息，
采用的语句是 select * from student where grade > 72 for update，这个时候 InnoDB 锁住的不仅是 80，95，而是所有在 72-80，80-95，以及 95 以上的所有记录。
为什么会 这样呢？实际上是因为如果不锁住这些行，那么如果另一个事务在此时插入了一条分数大于 72 的记录，那会导致第一次的事务两次查询的结果不一样，出现了幻读。
所以为了在满足事务隔离级别的情况下需要锁住所有满足条件的行。

#### 临键锁(Next-Key Locks)
NK 是一种记录锁和间隙锁的组合锁,既包含区间又包含记录。是 3 和 4 的组合形式，既锁住行也锁住间隙。并且采用的左开右闭的原则。InnoDB 对于查询都是采用这种锁的。
举个例子：
```sql
CREATE TABLE `a` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `uid` int(10) unsigned DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_uid` (`uid`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

INSERT INTO `a`(uid) VALUES (1);
INSERT INTO `a`(uid) VALUES (2);
INSERT INTO `a`(uid) VALUES (3);
INSERT INTO `a`(uid) VALUES (6);
INSERT INTO `a`(uid) VALUES (10);

# T1
START TRANSACTION WITH CONSISTENT SNAPSHOT; //1
SELECT * FROM a WHERE uid = 6 for UPDATE; //2
COMMIT;  //5

# T2
START TRANSACTION WITH CONSISTENT SNAPSHOT;  //3
INSERT INto a(uid) VALUES(11);
INSERT INto a(uid) VALUES(5);  //4
SELECT * FROM a WHERE uid = 6 for UPDATE;
COMMIT;
ROLLBACK;
```

按照上面 1，2，3，4 的顺序执行会发现第 4 步被阻塞了，必须执行完第 5 步后才能插入成功。这里会很奇怪明明锁住的是uid=6 的这一行，
为什么不能插入 5 呢？原因就是这里采用了 next-key 的算法，锁住的是(3,10)整个区间。

注意：
如果对于唯一键值的锁定，Next-Key Lock 降级为 RecordLock

### 表级别锁

#### 意向锁(Intention Locks)

* [产生原因](https://blog.csdn.net/a1102325298/article/details/86586629)

解决 **表锁** 与之前可能存在的 **行锁** 冲突，避免为了判断表是否存在行锁而去扫描全表的系统消耗。

* 意向锁的加锁规则

事务在获取行级 S 锁之前，必须获取其对应表的 IS 或 IX 锁
事务在获取行级 X 锁之前，必须获取其对应表的 IX 锁

* 作用

一种快速判断手动加的表锁与之前可能存在的行锁冲突的机制。（数据库在执行事务过程中，更新数据时会帮我们自动加行锁）

#### 插入意向锁
1.   插入意向锁是一种间隙Gap锁，不是意向锁，在insert操作时产生。
2.   在多事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待。
3.   假设有一个记录索引包含键值4和7，不同的事务分别插入5和6，每个事务都会产生一个加在4-7之间的插入意向锁，获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。
4.   插入意向锁不会阻止任何锁，对于插入的记录会持有一个记录锁。

### [乐观锁悲观锁](https://www.jianshu.com/p/d2ac26ca6525)

#### 悲观锁(Pessimistic Lock)


当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。
这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。
悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界(包括本系统当前的其他事务，以及来自外部系统的事务处理)修改持保守态度。
因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制(也只有数据库层提供的锁机制才能真正保证数据访问的排他性，
否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据)。

之所以叫做悲观锁，是因为这是一种对数据的修改持有悲观态度的并发控制方式。总是假设最坏的情况，每次读取数据的时候都默认其他线程会更改数据，因此需要进行加锁操作，当其他线程想要访问数据时，都需要阻塞挂起。悲观锁的实现：

1. 传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
2. Java 里面的同步 synchronized 关键字的实现。


#### 悲观锁主要分为共享锁和排他锁：

1. 共享锁【shared locks】又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。
2. 排他锁【exclusive locks】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，
其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。


悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。

#### 乐观锁(Optimistic Locking)

乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，
如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。

乐观锁机制采取了更加宽松的加锁机制。乐观锁是相对悲观锁而言，也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，
但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。

#### 乐观锁的实现：

1. CAS(compare and swap) 
    * 每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式。
2. 版本号控制 
    * 一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会+1。当线程A要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。



要解决冲突，一种办法是是锁，即基于锁的并发控制，比如2PL，这种方式开销比较高，而且无法避免死锁。

1. 多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读
2. 乐观并发控制（OCC）是一种用来解决写-写冲突的无锁并发控制，认为事务间争用没有那么多，所以先进行修改，在提交事务前，
检查一下事务开始后，有没有新提交改变，如果没有就提交，如果有就放弃并重试。乐观并发控制类似自选锁。乐观并发控制适用于低数据争用，写冲突比较少的环境。
多版本并发控制可以结合基于锁的并发控制来解决写-写冲突，即MVCC+2PL，也可以结合乐观并发控制来解决写-写冲突。

#### MVCC 
可以保证不阻塞地读到一致的数据。但是，MVCC 并没有对实现细节做约束，为此不同的数据库的语义有所不同，比如：postgres 对写操作也是乐观并发控制；在表中保存同一行数据记录的多个不同版本，每次写操作，都是创建，而回避更新；在事务提交时，按版本号检查当前事务提交的数据是否存在写冲突，则抛异常告知用户，回滚事务；innodb 则只对读无锁，写操作仍是上锁的悲观并发控制，这也意味着，innodb 中只能见到因死锁和不变性约束而回滚，而见不到因为写冲突而回滚；不像 postgres 那样对数据修改在表中创建新纪录，而是每行数据只在表中保留一份，在更新数据时上行锁，同时将旧版数据写入 undo log；表和 undo log 中行数据都记录着事务ID，在检索时，只读取来自当前已提交的事务的行数据；可见 MVCC 中的写操作仍可以按悲观并发控制实现，而 CAS 的写操作只能是乐观并发控制。还有一个不同在于，MVCC 在语境中倾向于 “对多行数据打快照造平行宇宙”，然而 CAS 一般只是保护单行数据而已。比如 mongodb 有 CAS 的支持，但不能说这是 MVCC。
