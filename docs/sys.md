
## 操作系统：

linux的内存管理机制，内存寻址方式，什么叫虚拟内存，内存调页算法，任务调度算法、

Linux虚拟内存的实现需要6种机制的支持：地址映射机制、内存分配回收机制、缓存和刷新机制、请求页机制、交换机制和内存共享机制

内存管理程序通过映射机制把用户程序的逻辑地址映射到物理地址。当用户程序运行时，如果发现程序中要用的虚地址没有对应的物理内存，就发出了请求页要求。如果有空闲的内存可供分配，就请求分配内存(于是用到了内存的分配和回收)，并把正在使用的物理页记录在缓存中(使用了缓存机制)。如果没有足够的内存可供分配，那么就调用交换机制；腾出一部分内存。另外，在地址映射中要通过TLB(翻译后援存储器)来寻找物理页；交换机制中也要用到交换缓存，并且把物理页内容交换到交换文件中，也要修改页表来映射文件地址。
    进程和线程、进程间及线程通信方式、共享内存的使用实现原理

### 死锁必要条件及避免算法、

1. 资源不能共享，只能由一个进程使用。
2. 请求与保持（Hold andwait）：已经得到资源的进程可以再次申请新的资源。
3. 不可剥夺（Nopre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。
4. 循环等待：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源

### 处理死锁的策略：
1. 忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。
2. 检测死锁并且恢复。
3. 仔细地对资源进行动态分配，以避免死锁。
4. 通过破除死锁四个必要条件之一，来防止死锁产生。）


+ 动态链接和静态链接的区别、

动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在运行时再装入；而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了。


c程序辨别系统是16位or32位,大端or小端字节序、

16or32

    法一：int k=~0;

    if((unsigned int)k >63356) cout<<"at least 32bits"<<endl;
    else cout<<"16 bits"<<endl;

    法二：//32为系统

    int i=65536;
    cout<<i<<endl;
    int j=65535;
    cout<<j<<endl;
大or小

    1) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。
    2) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。
    举一个例子，比如数字0x12 34 56 78在内存中的表示形式为：

    1)大端模式：
    低地址 -----------------> 高地址
    0x12  |  0x34  |  0x56  |  0x78
    2)小端模式：
    低地址 ------------------> 高地址
    0x78  |  0x56  |  0x34  |  0x12

    32bit宽的数0x12345678在Little-endian模式以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：
    内存地址    小端模式存放内容    大端模式存放内容
    0x4000    0x78    0x12
    0x4001    0x56    0x34
    0x4002    0x34    0x56
    0x4003    0x12    0x78

    4)大端小端没有谁优谁劣，各自优势便是对方劣势：
    小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。
    大端模式 ：符号位的判定固定为第一个字节，容易判断正负。
    BOOL IsBigEndian()
    {
        int a = 0x1234;
        char b =  *(char *)&a;  //通过将int强制类型转换成char单字节，通过判断起始存储位置。即等于 取b等于a的低地址部分
        if( b == 0x12)
        {
            return TRUE;
        }
        return FALSE;
    }

    联合体union的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松地获得了CPU对内存采用Little-endian还是Big-endian模式读写：

    BOOL IsBigEndian()
    {
        union NUM
        {
            int a;
            char b;
        }num;
        num. a = 0x1234;
        if( num. b == 0x12 )
        {
            return TRUE;
        }
        return FALSE;
    }

    一般操作系统都是小端，而通讯协议是大端的。
    常见CPU的字节序
    Big Endian : PowerPC、IBM、Sun
    Little Endian : x86、DEC
    ARM既可以工作在大端模式，也可以工作在小端模式。

### 常见的信号、系统如何将一个信号通知到进程、

    信号机制是进程之间相互传递消息的一种方法，信号全称为软中断信号，也有人称作软中断。
    进程之间可以互相通过系统调用kill发送软中断信号。
    SIGHUP 1 A 终端挂起或者控制进程终止
    SIGINT 2 A 键盘中断（如break键被按下）
    SIGQUIT 3 C 键盘的退出键被按下
    SIGILL 4 C 非法指令
    SIGABRT 6 C 由abort(3)发出的退出指令
    SIGFPE 8 C 浮点异常
    SIGKILL 9 AEF Kill信号
    SIGSEGV 11 C 无效的内存引用
    SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道

信号机制是异步的；当一个进程接收到一个信号时，它会立刻处理这个信号，而不会等待当前函数甚至当前一行代码结束运行。信号有几十种，分别代表着不同的意义。信号之间依靠它们的值来区分，但是通常在程序中使用信号的名字来表示一个信号。在Linux系统中，这些信号和以它们的名称命名的常量均定义在/usr/include/bits/signum. h文件中。（通常程序中不需要直接包含这个头文件，而应该包含<signal. h>。）

信号事件的发生有两个来源：硬件来源(比如我们按下了键盘或者其它硬件故障)；软件来源，最常用发送信号的系统函数是kill, raise, alarm和setitimer以及sigqueue函数，软件来源还包括一些非法运算等操作。

发送信号的主要函数有：kill()、raise()、 sigqueue()、alarm()、setitimer()以及abort()。



进程可以通过三种方式来响应一个信号：（1）忽略信号，即对信号不做任何处理，其中，有两个信号不能忽略：SIGKILL及SIGSTOP；（2）捕捉信号。定义信号处理函数，当信号发生时，执行相应的处理函数；（3）执行缺省操作，

### linux系统的各类同步机制、linux系统的各类异步机制、

如何实现守护进程

#### 守护进程最重要的特性是后台运行。

1.  在后台运行。
    为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemon在子进程中后台执行。

    if(pid=fork())
    exit(0); //是父进程，结束父进程，子进程继续
2.  脱离控制终端，登录会话和进程组

    有必要先介绍一下Linux中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。登录会话可以包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的就是要摆脱它们，使之不受它们的影响。方法是在第1点的基础上，调用setsid()使进程成为会话组长：

    setsid();

    说明：当进程是会话组长时setsid()调用失败。但第一点已经保证进程不是会话组长。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。

3.  禁止进程重新打开控制终端

    现在，进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过使进程不再成为会话组长来禁止进程重新打开控制终端：

    if(pid=fork()) exit(0); //结束第一子进程，第二子进程继续（第二子进程不再是会话组长）

4.  关闭打开的文件描述符

    进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。按如下方法关闭它们：

    for(i=0;i 关闭打开的文件描述符close(i);>

5.  改变当前工作目录

    进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如 /tmpchdir("/")

6.  重设文件创建掩模

    进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：umask(0);

7.  处理SIGCHLD信号

    处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸进程（zombie）从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将 SIGCHLD信号的操作设为SIG_IGN。

    signal(SIGCHLD,SIG_IGN);

    这样，内核在子进程结束时不会产生僵尸进程。这一点与BSD4不同，BSD4下必须显式等待子进程结束才能释放僵尸进程。

### 标准库函数和系统调用的区别，

1. 系统调用

    系统调用提供的函数如open, close, read, write, ioctl等，需包含头文件unistd. h。以write为例：其函数原型为 size_t write(int fd, const void *buf, size_t nbytes)，其操作对象为文件描述符或文件句柄fd(file descriptor)，要想写一个文件，必须先以可写权限用open系统调用打开一个文件，获得所打开文件的fd，例如fd=open(/"/dev/video/", O_RDWR)。fd是一个整型值，每新打开一个文件，所获得的fd为当前最大fd加1。Linux系统默认分配了3个文件描述符值：0－standard input，1－standard output，2－standard error。

    系统调用通常用于底层文件访问（low-level file access），例如在驱动程序中对设备文件的直接访问。

    系统调用是操作系统相关的，因此一般没有跨操作系统的可移植性。

    系统调用发生在内核空间，因此如果在用户空间的一般应用程序中使用系统调用来进行文件操作，会有用户空间到内核空间切换的开销。事实上，即使在用户空间使用库函数来对文件进行操作，因为文件总是存在于存储介质上，因此不管是读写操作，都是对硬件（存储器）的操作，都必然会引起系统调用。也就是说，库函数对文件的操作实际上是通过系统调用来实现的。例如C库函数fwrite()就是通过write()系统调用来实现的。

    这样的话，使用库函数也有系统调用的开销，为什么不直接使用系统调用呢？这是因为，读写文件通常是大量的数据（这种大量是相对于底层驱动的系统调用所实现的数据操作单位而言），这时，使用库函数就可以大大减少系统调用的次数。这一结果又缘于缓冲区技术。在用户空间和内核空间，对文件操作都使用了缓冲区，例如用fwrite写文件，都是先将内容写到用户空间缓冲区，当用户空间缓冲区满或者写操作结束时，才将用户缓冲区的内容写到内核缓冲区，同样的道理，当内核缓冲区满或写结束时才将内核缓冲区内容写到文件对应的硬件媒介。
2. 库函数调用

    标准C库函数提供的文件操作函数如fopen, fread, fwrite, fclose,fflush, fseek等，需包含头文件stdio. h。以fwrite为例，其函数原型为size_t fwrite(const void *buffer,size_t size, size_t item_num, FILE *pf)，其操作对象为文件指针FILE *pf，要想写一个文件，必须先以可写权限用fopen函数打开一个文件，获得所打开文件的FILE结构指针pf，例如pf=fopen(/"~/proj/filename/",/"w/")。实际上，由于库函数对文件的操作最终是通过系统调用实现的，因此，每打开一个文件所获得的FILE结构指针都有一个内核空间的文件描述符fd与之对应。同样有相应的预定义的FILE指针：stdin－standard input，stdout－standard output，stderr－standard error。

    库函数调用通常用于应用程序中对一般文件的访问。
    库函数调用是系统无关的，因此可移植性好。
    由于库函数调用是基于C库的，因此也就不可能用于内核空间的驱动程序中对设备的操作



## fd和PCB，

32位系统一个进程最多有多少堆内存?
+ :32位系统进程地址空间是4G, 用户可访问的空间是3G 左右。
+ 一个线程的默认栈大小是10M, 一个进程最多起300个线程。


