[toc]

# [http](https://www.cnblogs.com/an-wen/p/11180076.html)

## HTTP 发展史

|版本 | 时间| 内容| 发展现状|
|--|--|--|--|
| HTTP.09 | 1991 |只支持GET请求，并且不支持请求头|已经过时
| [HTTP1.0](https://tools.ietf.org/html/rfc1945) | 1996 | HTTP1.0版本虽然是支持长链接，但是默认情况还是短连接，需要使用keep-alive参数来告知服务器建立一个长链接| 今仍然被广泛使用，尤其是在代理服务器中。
| [HTTP1.1](https://tools.ietf.org/html/rfc2616) | 1997 | 1.引入了长链接,2.节约带宽,3.1.1版本中增加了host处理  |最流行的一个版本
| [HTTP2 ](https://tools.ietf.org/html/rfc7540) | 2015 | 1.多路复用, 2.引入了二进制格式 3.服务器推送| 目前用的比较少 
| [HTTPS ](https://tools.ietf.org/html/rfc2818) | 2000 |  HTTP Over TLS

---

## HTTP协议简介

超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。

HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。

2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP/2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。
## HTTP协议概述
HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。

尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。

通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息。


## HTTP工作原理
HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

以下是 HTTP 请求/响应的步骤：

\1. 客户端连接到Web服务器
一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.luffycity.com。

\2. 发送HTTP请求
通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

\3. 服务器接受请求并返回HTTP响应
Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。

\4. 释放连接TCP连接
若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

\5. 客户端浏览器解析HTML内容
客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：

浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;
解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;
浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;
服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
释放 TCP连接;
浏览器将该 html 文本并显示内容; 　

## HTTP请求方法
HTTP/1.1协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：

1. **GET** 向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。

2. **HEAD** 与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。

3. **POST** 向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。

4. **PUT** 向指定资源位置上传其最新内容。

5. **DELETE** 请求服务器删除Request-URI所标识的资源。

6. **TRACE** 回显服务器收到的请求，主要用于测试或诊断。

7. **OPTIONS** 这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用'*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。

8. **CONNECT** HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。

### 注意事项：

方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。
HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如PATCH（由 RFC 5789 指定的方法）用于将局部修改应用到资源。
### 问题总结：

#### get 与 post的区别

最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。

* 都包含请求头请求行，post多了请求body。
* GET在浏览器回退时是无害的，而POST会再次提交请求。
* GET产生的URL地址可以被Bookmark，而POST不可以。
* GET请求会被浏览器主动cache，而POST不会，除非手动设置。
* GET请求只能进行url编码，而POST支持多种编码方式。
* GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
* GET请求在URL中传送的参数是有长度限制的，而POST没有（因为浏览器对URL的长度有限制）。
* 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
* GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
* GET参数通过URL传递，POST放在Request body中。
:GET提交的数据会放在URL之后，也就是请求行里面，以?分割URL和传输参数，参数之间以&相连，如EditBook?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的请求体中.

GET和POST还有一个重大区别，简单的说：
GET产生一个TCP数据包；POST产生两个TCP数据包。

## http 请求格式

请求报文由4个部分组成，它们分别是**请求行、请求头部、空行和报文主体**；请求行、请求头部和空行是必需的而报文主体是可选的。

![avatar](tcp_ip_pic/http_req_header.jpg)
![avatar](tcp_ip_pic/http_req_header_demo.png)

## http 响应格式

响应报文也由4个部分组成，它们分别是**状态行、响应头部、空行和报文主体**；状态行、响应头部和空行是必需的而报文主体是可选的。
![avatar](tcp_ip_pic/http_response_demo.jpg)
![avatar](tcp_ip_pic/http_res_demo.png)

## pratice

### nc demo
```
nc -lv localhost 3000
exec 10<> /dev/tcp/localhost/3000
#
cd /proc/$$/fd;ll
tcpdump -X -i lo port 3000
```

### website test

```
exec 11<> /dev/tcp/www.baidu.com/80

#send req
echo -e "GET / HTTP/1.1\n" >&11

#recv rsp
cat <&11
```

## 响应码

+ 2xx:成功响应码
+ 3xx:重定向
+ 4xx:客服端错误
+ 5xx:服务端错误



作者：wavesnow
链接：https://www.jianshu.com/p/d4767b797e57

[重定向状态码详解:mozilla.org](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Redirections)  

+ 1.0 状态码：

| Status-Code    | res| 意义|
| -- | -- | -- |
| "200"   | OK
| "201"   | Created|
| "202"   | Accepted|
| "204"   | No Content| 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档|
| "301"   | Moved Permanently| 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替|
| "302"   | Found | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| "303"   | See Other | 查看其它地址。与302类似。POST重定向为GET
| "304"   | Not Modified|未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
| "305"   | Use Proxy | 使用代理。所请求的资源必须通过代理访问
| "400"   | Bad Request| 客户端请求的语法错误，服务器无法理解
| "401"   | Unauthorized|请求要求用户的身份认证
| "402"   | Payment Required| 保留，将来使用
| "403"   | Forbidden| 服务器理解请求客户端的请求，但是拒绝执行此请求
| "404"   | Not Found| 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
| "405"   | Method Not Allowed|客户端请求中的方法被禁止
| "500"   | Internal Server Error| 服务器内部错误，无法完成请求
| "501"   | Not Implemented|服务器不支持请求的功能，无法完成请求
| "502"   | Bad Gateway|作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
| "503"   | Service Unavailable|由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中

----


## https

+ HTTP： 直接通过明文在浏览器和服务器之间传递信息。
+ HTTPS： 采用 对称加密 和 非对称加密 结合的方式来保护浏览器和服务端之间的通信安全。

1. 对称加密算法使用起来简单快捷，密钥较短，且破译困难，除了数据加密标准（DES），另一个对称密钥加密系统是国际数据加密算法（IDEA），它比DES的加密性好，而且对计算机功能要求也没有那么高。IDEA加密标准由PGP（Pretty Good Privacy）系统使用。 常见的对称加密算法有DES、3DES、Blowfish、IDEA、RC4、RC5、RC6和AES 

2. 非对称加密算法, [RSA原理--阮一峰](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)

![avatar](http_pic/https_proc.webp)

### CA 证书的签发与校验 
![avatar](http_pic/CA-cert.png)

#### CA 签发证书的过程，如上图左边部分：
首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；
然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；
最后将 Certificate Signature 添加在文件证书上，形成数字证书；
#### 客户端校验服务端的数字证书的过程，如上图右边部分：
首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；
最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。


### 为什么数据传输是用对称加密？
首先：非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。
另外：在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。



## [WebSocket](http://www.52im.net/thread-331-1-1.html)





## HTTP 问题总结
### 1. 如何判断一个你打向的ip在国内还是国外，用什么工具？
使用IP库判断IP地址


### 2. 内部接口互相调用，如果要增加鉴权，鉴权是放在header里还是body里，为什么
### 3. 外部接口调用，如果要有防重放的攻击检测，如何保证安全性
[如何防止重放攻击](https://blog.csdn.net/weixin_39986856/article/details/82657808)

### 4. ssl和https
HTTP 是一个网络协议，是专门用来帮你传输 Web，ssl中文叫安全套接层为了结局传输内容会被偷窥（嗅探）和篡改，https是 “HTTP 协议”和“SSL/TLS 协议”的组合。
### 5. 什么是SYN Flood攻击？
https://zhuanlan.zhihu.com/p/29539671
![avatar](http_pic/syn_flood.jpg)
SYN洪水可以以三种不同的方式发生：

#### 直接攻击
IP地址不被欺骗的SYN Flood被称为直接攻击。在这次攻击中，攻击者根本不掩盖其IP地址。由于攻击者使用具有真实IP地址的单个源设备来创建攻击，因此攻击者极易受到发现和缓解的影响。为了在目标机器上创建半开状态，黑客可以防止其机器响应服务器的SYN-ACK数据包。这通常是通过阻止除SYN数据包之外的传出数据包的防火墙规则来实现的，或者在到达恶意用户机器之前过滤任何传入的SYN-ACK数据包。实际上，这种方法很少使用（如果有的话），因为减轻是非常简单的 – 只是阻止每个恶意系统的IP地址。

#### 欺骗性攻击
恶意用户也可以欺骗他们发送的每个SYN数据包上的IP地址，以抑制缓解工作，使其身份更难发现。虽然数据包可能被欺骗，但这些数据包可能会被追溯到其来源。很难做这种侦探工作，但并不是不可能的，特别是如果互联网服务提供商（ISP）愿意帮助的话。

#### 分布式攻击（DDoS）
如果使用僵尸网络创建攻击，则将攻击溯源到源的可能性很低。对于增加的混淆级别，攻击者可能会使每个分布式设备也欺骗发送数据包的IP地址。如果攻击者正在使用诸如未来僵尸网络的僵尸网络，他们通常不会关心被感染设备的IP掩蔽

通过使用SYN Flood攻击，恶意攻击者可以尝试在目标设备或服务中创建拒绝服务，其流量大大低于其他DDoS攻击。为了使目标周边的网络基础设施饱和，SYN攻击只需要比目标操作系统中可用的积压更大的体积攻击。如果攻击者能够确定积压的大小，并且在超时之前每个连接将被打开多长时间，攻击者可以定位禁用系统所需的确切参数，从而将总流量减少到最小必要量以创建拒绝服务。

### 6. HTTP1.0和HTTP1.1的一些区别

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

+ **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

+ **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

+ **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

+ **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

+ **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

HTTP2.0和HTTP1.X相比的新特性

+ **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

+ **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

+ **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

+ **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。 

