## hash 散列

 冲突解决方法
 
### 链接法

把散列到同一槽中的所有元素都放在一个链表中。

### 开放寻址法
这个方法的基本思想是：当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。这个过程可用下式描述： 
H i ( key ) = ( H ( key )+ d i ) mod m ( i = 1,2,…… ， k ( k ≤ m – 1)) 
其中： H ( key ) 为关键字 key 的直接哈希地址， m 为哈希表的长度， di 为每次再探测时的地址增量。 
采用这种方法时，首先计算出元素的直接哈希地址 H ( key ) ，如果该存储单元已被其他元素占用，则继续查看地址为 H ( key ) + d 2 的存储单元，如此重复直至找到某个存储单元为空时，将关键字为 key 的数据元素存放到该单元。 
增量 d 可以有不同的取法，并根据其取法有不同的称呼： 

( 1 ) d i ＝ 1 ， 2 ， 3 ， …… 线性探测再散列； 

( 2 ) d i ＝ 1^2 ，－ 1^2 ， 2^2 ，－ 2^2 ， k^2， -k^2…… 二次探测再散列； 

( 3 ) d i ＝ 伪随机序列 伪随机再散列；

### 再哈希

当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。
比如上面第一次按照姓首字母进行哈希，如果产生冲突可以按照姓字母首字母第二位进行哈希，再冲突，第三位，直到不冲突为止

### 建立一个公共溢出区
假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录。
经过以上方法，基本可以解决掉hash算法冲突的问题。

### 完全散列

第一级与带链接的散列表基本上是一样的，利用全域散列函数将关键字散列到m个槽中，
利用**二次散列表**以及相关函数代替链表，精心选择散列函数，保证第二级上不出现冲突。


