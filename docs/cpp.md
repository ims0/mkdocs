#

## [c++常见问题汇总](https://www.cnblogs.com/inception6-lxc/p/8686156.html)

## C++关键字解释
###  mutable

mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。

在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。
　　我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。

### final
#### 禁用继承
C++11中允许将类标记为final，方法时直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。

实例如下：
```
class Super final
{
  //......
};
```
#### 禁用重写

C++中还允许将方法标记为fianal，这意味着无法再子类中重写该方法。这时final关键字至于方法参数列表后面，如下
```
class Super
{
  public:
    virtual void SomeMethod() final;
};
```
### explicit

首先, C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).

explicit关键字的作用就是防止类构造函数的隐式自动转换.

上面也已经说过了, explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了
但是, 也有一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数, 

## [this指针怎么传递](https://blog.csdn.net/xuruhua/article/details/80656580)
### this指针的类型：
类类型* const this指针并不是对象本身的一部分，不影响sizeof的结果 this的作用域在类”成员函数”的内部 this指针是”类成员函数”的第一个默认隐含参数，编译器自动维护 传递，类编写者不能显式传递 只有在类的非静态成员函数中才可以使用this指针，其它任何函数都 不可以
```
class Test {
public:
  void FunTest() {
    cout << this << endl; //can be call when pt == NULL
    //_data = 10;//segmentation fault when pt ==NULL
  }
  static void func() { cout << "static" << endl; }
  int _data;
};

int main() {
  Test t;
  t.FunTest();//lea -0x14(%rbp),%rax; mov %rax,%rdi; callq <Test::FunTest()>
  t.func(); //callq <Test::func()>;
  Test *pt = &t; // lea -0x14(%rbp),%rax;mov  %rax,-0x10(%rbp)
  pt->FunTest(); // //lea -0x14(%rbp),%rax; mov %rax,%rdi; callq <Test::FunTest()>
  pt = NULL; //movq   $0x0,-0x10(%rbp)
  cout << "pt:" << pt << endl;
  pt->FunTest(); //mov  -0x10(%rbp),%rax; mov  %rax,%rdi; callq <Test::FunTest()>
  return 0;
}
```


## 对象实例化问题

### 设计一个不能被继承的类。
**构造函数或析构函数为private**，所以该类是无法被继承的，
构造函数为私有的类，其对象只能是static对象，单例模式中，应该把构造函数设置为私有，防止在外部创建对象。

### 定义一个只能在堆上定义对象的类
**析构函数定义为private**，在栈上不能自动调用析构函数，只能手动调用。也可以将构造函数定义为private，但这样需要手动写一个函数实现对象的构造。

### 定义一个只能在栈上定义对象的类
**operator new和operator delete定义为private**，这样使用new操作符创建对象时候，无法调用operator new，delete销毁对象也无法调用operator delete。


## [构造函数详解](https://www.cnblogs.com/alantu2018/p/8459250.html)

### 拷贝构造调用时机
1. 对象作为入参
2. 对象作为返回值
3. 用一个对象初始化另一个对象

### 浅拷贝

 所谓浅拷贝，指的是在对象复制时，只对对象中的数据成员进行简单的赋值，默认拷贝构造函数执行的也是浅拷贝。大多情况下“浅拷贝”已经能很好地工作了，但是一旦对象存在了动态成员，那么浅拷贝就会出问题了

### 深拷贝

 在“深拷贝”的情况下，对于对象中动态成员，就不能仅仅简单地赋值了，而应该重新动态分配空间

### 防止默认拷贝发生

通过对对象复制的分析，我们发现对象的复制大多在进行“值传递”时发生，这里有一个小技巧可以防止按值传递——声明一个私有拷贝构造函数。甚至不必去定义这个拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类对象，将得到一个编译错误，从而可以避免按值传递或返回对象。

### 那些是拷贝构造函数
```
X::X(X); 
X::X(const X&);   //拷贝构造函数
X::X(X&, int a=1);   //拷贝构造函数
X::X(X&, int a=1, int b=2);  //拷贝构造函数
```

解答：对于一个类X, 如果一个构造函数的第一个参数是下列之一:
+ X&
+ const X&
+ volatile X&
+ const volatile X&

且没有其他参数或其他参数都有默认值,那么这个函数是拷贝构造函数.

###  一个类中可以存在多于一个的拷贝构造函数吗?
解答：类中可以存在超过一个拷贝构造函数。
```
class X { 
public: 
  X(const X&); // const 的拷贝构造 
  X(X&); // 非const的拷贝构造 
};
```

注意,如果一个类中只存在一个参数为 X& 的拷贝构造函数,那么就不能使用const X或volatile X的对象实行拷贝初始化.
  如果一个类中没有定义拷贝构造函数,那么编译器会自动产生一个默认的拷贝构造函数。
  这个默认的参数可能为 X::X(const X&)或 X::X(X&),由编译器根据上下文决定选择哪一个。

### C++构造函数以及析构函数的若干面试问题
 
Q1：构造函数能否重载，析构函数能否重载，为什么？
A1：构造函数可以，析构函数不可以。

Q2：析构函数为什么一般情况下要声明为虚函数？
A2：虚函数是实现多态的基础，当我们通过基类的指针是析构子类对象时候，如果不定义成虚函数，那只调用基类的析构函数，子类的析构函数将不会被调用。如       果定义为虚函数，则子类父类的析构函数都会被调用。

Q3：什么情况下必须定义拷贝构造函数？
A3：当类的对象用于函数值传递时（值参数，返回类对象），拷贝构造函数会被调用。如果对象复制并非简单的值拷贝，那就必须定义拷贝构造函数。例如大的堆       栈数据拷贝。如果定义了拷贝构造函数，那也必须重载赋值操作符。


## char \*a 与char a[] 的区别
char \*d = "hello" 中的a是指向第一个字符‘a'的一个指针；char s[20] = "hello" 中数组名a也是执行数组第一个字符'h'的指针。现执行下列操作：strcat(d, s)。把字符串加到指针所指的字串上去，出现段错误，本质原因：\*d="0123456789"存放在常量区，是无法修的。而数组是存放在栈中，是可以修改的。两者区别如下：

+ 读写能力：char \*a = "abcd"此时"abcd"存放在常量区。通过指针只可以访问字符串常量，而不可以改变它。而char a[20] = "abcd"; 此时 "abcd"存放在栈。可以通过指针去访问和修改数组内容。

+ 赋值时刻：char \*a = "abcd"是在编译时就确定了（因为为常量）。而char a[20] = "abcd"; 在运行时确定

+ 存取效率：char \*a = "abcd"; 存于静态存储区。在栈上的数组比指针所指向字符串快。因此慢，而char a[20] = "abcd"存于栈上，快。
+ 另外注意：char a[] = "01234"，虽然没有指明字符串的长度，但是此时系统已经开好了，就是大小为6-----'0' '1' '2' '3' '4' '5' '\0'，(注意strlen(a)是不计'\0')

## [四个强转](https://blog.csdn.net/Bob__yuan/article/details/88044361)

1、static_cast，2、const_cast，3、reinterpret_cast，4、dynamic_cast

### 1）static_cast
  这应该四种中是最常见的。用法为 static_cast<type-id> (expression)。
该运算符把 expression 转换为 type-id 类型，但没有运行时类型检查来保证转换的安全性。
主要用法如下：

1. 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。
   进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；
   进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
2. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
3. 把空指针转换成目标类型的空指针。
4. 把任何类型的表达式转换成void类型。

### 2）const_cast

上边的 static_cast 不能将 const int\* 转成 int\*，const_cast 就可以，用法为 const_cast<type-i> (expression)。如下面代码

### 3）reinterpret_cast

reinterpret_cast 主要有三种强制转换用途：

1. 改变指针或引用的类型
2. 将指针或引用转换为一个足够长度的整形
3. 将整型转换为指针或引用类型。

用法为 reinterpret_cast <type-id> (expression)。
type-id 必须是一个指针、引用、算术类型、函数针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。
  我们映射到的类型仅仅是为了故弄玄虚和其他目的，这是所有映射中最危险的。(这句话是C++编程思想中的原话)。因此, 你需要谨慎使用 reinterpret_cast。

### 4）dynamic_cast(运行时处理)

用法为 dynamic_cast<type-id> (expression)。
几个特点如下：

1. 其他三种都是编译时完成的，dynamic_cast 是运行时处理的，运行时要进行类型检查。
2. 不能用于内置的基本数据类型的强制转换
3. dynamic_cast 要求 <> 内所描述的目标类型必须为指针或引用。dynamic_cast 转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回 nullptr
4. 在类的转换时，在类层次间进行上行转换（子类指针指向父类指针）时，dynamic_cast 和 static_cast 的效果是一样的。在进行下行转换（父类指针转化为子类指针）时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全。 向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。
5. 使用 dynamic_cast 进行转换的，基类中一定要有虚函数，否则编译不通过（类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义）。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表（C++中的虚函数基本原理这篇文章写得不错，https://blog.csdn.net/xiejingfa/article/details/50454819）。

## [迭代器失效的情况](https://www.cnblogs.com/fnlingnzb-learner/p/9300073.html)

迭代器失效分三种情况考虑，也是分三种数据结构考虑，分别为数组型，链表型，树型数据结构。

**数组型数据结构**：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(*iter)(或erase(*iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);

**链表型数据结构**：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).

**树形数据结构**： 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。

注意：经过erase(iter)之后的迭代器完全失效，该迭代器iter不能参与任何运算，包括iter++,*iter


##  成员初始化列表的概念

因为使用成员初始化列表进行初始化的话，会直接使用传入参数的**拷贝构造函数**进行初始化，省去了一次执行传入参数的默认构造函数的过程，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些。

另外，有三种情况是必须使用成员初始化列表进行初始化的：

1. 常量成员的初始化，因为常量成员只能初始化不能赋值
2. 引用类型
3. 没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化

```
struct Base{
    //Base()=default; //显式要求生成默认构造函数,否则存在其它构造函数时不生成。
    Base(int a):a_(a){}
    int a_;
};

struct Derived{
    Derived(int a):b(a){}
    Base b;
};
int main()
{
    //Base b; //error
    Base b(1);
    return 0;
}
```


