[toc]

## [c++常见问题汇总](https://www.cnblogs.com/inception6-lxc/p/8686156.html)

## 分区简介
1. 栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
2. 堆区（heap）—一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表
3. 全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态　　                                变量在相邻的另一块区域。  程序结束后由系统释放。
4. 常量区—常量字符串就是放在这里的，直到程序结束后由系统释放。上面的问题就在这里！！！
5. 代码区—存放函数体的二进制代码。

## 分区详解
1）代码区（text segment）。代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。代码段： 代码段（code segment/text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。代码区的指令中包括操作码和要操作的对象（或对象地址引用）。如果是立即数（即具体的数值，如5），将直接包含在代码中；如果是局部数据，将在栈区分配空间，然后引用该数据地址；如果是BSS区和数据区，在代码中同样将引用该数据地址。另外，代码段还规划了局部数据所申请的内存空间信息。

（2）全局初始化数据区/静态数据区（Data Segment）。只初始化一次。数据段： 数据段（data segment ）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。data段中的静态数据区存放的是程序中已初始化的全局变量、静态变量和常量。

（3）未初始化数据区（BSS）。在运行时改变其值。BSS 段： BSS 段（bss segment ）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS 是英文Block Started by Symbol 的简称。BSS 段属于静态内存分配，即程序一开始就将其清零了。一般在初始化时BSS段部分将会清零。

（4）栈区（stack）。由编译器自动分配释放，存放函数的参数值、局部变量的值等。存放函数的参数值、局部变量的值，以及在进行任务切换时存放当前任务的上下文内容。其操作方式类似于数据结构中的栈。每当一个函数被调用，该函数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，这就是C实现函数递归调用的方法。每执行一次递归函数调用，一个新的栈框架就会被使用，这样这个新实例栈里的变量就不会和该函数的另一个实例栈里面的变量混淆。栈(stack) ：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧"{}"中定义的变量（但不包括static 声明的变量，static 意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

（5）堆区（heap）。用于动态内存分配。堆在内存中位于bss区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时有可能由OS回收。堆(heap)： 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并将在内存中为这些段分配空间。栈段亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显式地申请和释放空间。

另外，可执行程序在运行时具有相应的程序属性。在有操作系统支持时，这些属性页由操作系统管理和维护。

C语言程序编译完成之后，已初始化的全局变量保存在DATA段中，未初始化的全局变量保存在BSS段中。TEXT和DATA段都在可执行文件中，由系统从可执行文件中加载；而BSS段不在可执行文件中，由系统初始化。BSS段只保存没有值的变量，所以事实上它并不需要保存这些变量的映像。运行时所需要的BSS段大小记录在目标文件中，但是BSS段并不占据目标文件的任何空间。




## char *a 与char a[] 的区别
char *d = "hello" 中的a是指向第一个字符‘a'的一个指针；char s[20] = "hello" 中数组名a也是执行数组第一个字符'h'的指针。现执行下列操作：strcat(d, s)。把字符串加到指针所指的字串上去，出现段错误，本质原因：*d="0123456789"存放在常量区，是无法修的。而数组是存放在栈中，是可以修改的。两者区别如下：

+ 读写能力：char *a = "abcd"此时"abcd"存放在常量区。通过指针只可以访问字符串常量，而不可以改变它。而char a[20] = "abcd"; 此时 "abcd"存放在栈。可以通过指针去访问和修改数组内容。

+ 赋值时刻：char *a = "abcd"是在编译时就确定了（因为为常量）。而char a[20] = "abcd"; 在运行时确定

+ 存取效率：char *a = "abcd"; 存于静态存储区。在栈上的数组比指针所指向字符串快。因此慢，而char a[20] = "abcd"存于栈上，快。
+ 另外注意：char a[] = "01234"，虽然没有指明字符串的长度，但是此时系统已经开好了，就是大小为6-----'0' '1' '2' '3' '4' '5' '\0'，(注意strlen(a)是不计'\0')

 
