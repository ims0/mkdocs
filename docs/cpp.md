#

## [c++常见问题汇总](https://www.cnblogs.com/inception6-lxc/p/8686156.html)

##  mutable

mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。

在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。
　　我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。

## [this指针怎么传递](https://blog.csdn.net/xuruhua/article/details/80656580)
### this指针的类型：
类类型* const this指针并不是对象本身的一部分，不影响sizeof的结果 this的作用域在类”成员函数”的内部 this指针是”类成员函数”的第一个默认隐含参数，编译器自动维护 传递，类编写者不能显式传递 只有在类的非静态成员函数中才可以使用this指针，其它任何函数都 不可以
```
class Test {
public:
  void FunTest() {
    cout << this << endl; //can be call when pt == NULL
    //_data = 10;//segmentation fault when pt ==NULL
  }
  static void func() { cout << "static" << endl; }
  int _data;
};

int main() {
  Test t;
  t.FunTest();//lea -0x14(%rbp),%rax; mov %rax,%rdi; callq <Test::FunTest()>
  t.func(); //callq <Test::func()>;
  Test *pt = &t; // lea -0x14(%rbp),%rax;mov  %rax,-0x10(%rbp)
  pt->FunTest(); // //lea -0x14(%rbp),%rax; mov %rax,%rdi; callq <Test::FunTest()>
  pt = NULL; //movq   $0x0,-0x10(%rbp)
  cout << "pt:" << pt << endl;
  pt->FunTest(); //mov  -0x10(%rbp),%rax; mov  %rax,%rdi; callq <Test::FunTest()>
  return 0;
}
```


## 对象实例化问题

### 设计一个不能被继承的类。
构造函数或析构函数为私有函数，所以该类是无法被继承的，
构造函数为私有的类，其对象只能是static对象，单例模式中，应该把构造函数设置为私有，防止在外部创建对象。

### 定义一个只能在堆上定义对象的类
只能在堆内存上实例化的类：将析构函数定义为private，在栈上不能自动调用析构函数，只能手动调用。也可以将构造函数定义为private，但这样需要手动写一个函数实现对象的构造。

### 定义一个只能在栈上定义对象的类
只能在栈内存上实例化的类：将函数operator new和operator delete定义为private，这样使用new操作符创建对象时候，无法调用operator new，delete销毁对象也无法调用operator delete。

## 分区简介
1. 栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
2. 堆区（heap）—一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表
3. 全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态　　                                变量在相邻的另一块区域。  程序结束后由系统释放。
4. 常量区—常量字符串就是放在这里的，直到程序结束后由系统释放。上面的问题就在这里！！！
5. 代码区—存放函数体的二进制代码。

## 分区详解
1）代码区（text segment）。代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。代码段： 代码段（code segment/text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。代码区的指令中包括操作码和要操作的对象（或对象地址引用）。如果是立即数（即具体的数值，如5），将直接包含在代码中；如果是局部数据，将在栈区分配空间，然后引用该数据地址；如果是BSS区和数据区，在代码中同样将引用该数据地址。另外，代码段还规划了局部数据所申请的内存空间信息。

（2）全局初始化数据区/静态数据区（Data Segment）。只初始化一次。数据段： 数据段（data segment ）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。data段中的静态数据区存放的是程序中已初始化的全局变量、静态变量和常量。

（3）未初始化数据区（BSS）。在运行时改变其值。BSS 段： BSS 段（bss segment ）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS 是英文Block Started by Symbol 的简称。BSS 段属于静态内存分配，即程序一开始就将其清零了。一般在初始化时BSS段部分将会清零。

（4）栈区（stack）。由编译器自动分配释放，存放函数的参数值、局部变量的值等。存放函数的参数值、局部变量的值，以及在进行任务切换时存放当前任务的上下文内容。其操作方式类似于数据结构中的栈。每当一个函数被调用，该函数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，这就是C实现函数递归调用的方法。每执行一次递归函数调用，一个新的栈框架就会被使用，这样这个新实例栈里的变量就不会和该函数的另一个实例栈里面的变量混淆。栈(stack) ：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧"{}"中定义的变量（但不包括static 声明的变量，static 意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

（5）堆区（heap）。用于动态内存分配。堆在内存中位于bss区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时有可能由OS回收。堆(heap)： 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并将在内存中为这些段分配空间。栈段亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显式地申请和释放空间。

另外，可执行程序在运行时具有相应的程序属性。在有操作系统支持时，这些属性页由操作系统管理和维护。

C语言程序编译完成之后，已初始化的全局变量保存在DATA段中，未初始化的全局变量保存在BSS段中。TEXT和DATA段都在可执行文件中，由系统从可执行文件中加载；而BSS段不在可执行文件中，由系统初始化。BSS段只保存没有值的变量，所以事实上它并不需要保存这些变量的映像。运行时所需要的BSS段大小记录在目标文件中，但是BSS段并不占据目标文件的任何空间。




## char \*a 与char a[] 的区别
char \*d = "hello" 中的a是指向第一个字符‘a'的一个指针；char s[20] = "hello" 中数组名a也是执行数组第一个字符'h'的指针。现执行下列操作：strcat(d, s)。把字符串加到指针所指的字串上去，出现段错误，本质原因：\*d="0123456789"存放在常量区，是无法修的。而数组是存放在栈中，是可以修改的。两者区别如下：

+ 读写能力：char \*a = "abcd"此时"abcd"存放在常量区。通过指针只可以访问字符串常量，而不可以改变它。而char a[20] = "abcd"; 此时 "abcd"存放在栈。可以通过指针去访问和修改数组内容。

+ 赋值时刻：char \*a = "abcd"是在编译时就确定了（因为为常量）。而char a[20] = "abcd"; 在运行时确定

+ 存取效率：char \*a = "abcd"; 存于静态存储区。在栈上的数组比指针所指向字符串快。因此慢，而char a[20] = "abcd"存于栈上，快。
+ 另外注意：char a[] = "01234"，虽然没有指明字符串的长度，但是此时系统已经开好了，就是大小为6-----'0' '1' '2' '3' '4' '5' '\0'，(注意strlen(a)是不计'\0')

## [四个强转](https://blog.csdn.net/Bob__yuan/article/details/88044361)

1、static_cast，2、const_cast，3、reinterpret_cast，4、dynamic_cast

### 1）static_cast
  这应该四种中是最常见的。用法为 static_cast<type-id> (expression)。
该运算符把 expression 转换为 type-id 类型，但没有运行时类型检查来保证转换的安全性。
主要用法如下：

1. 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。
   进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；
   进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
2. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
3. 把空指针转换成目标类型的空指针。
4. 把任何类型的表达式转换成void类型。

### 2）const_cast

上边的 static_cast 不能将 const int\* 转成 int\*，const_cast 就可以，用法为 const_cast<type-i> (expression)。如下面代码

### 3）reinterpret_cast

reinterpret_cast 主要有三种强制转换用途：

1. 改变指针或引用的类型
2. 将指针或引用转换为一个足够长度的整形
3. 将整型转换为指针或引用类型。

用法为 reinterpret_cast <type-id> (expression)。
type-id 必须是一个指针、引用、算术类型、函数针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。
  我们映射到的类型仅仅是为了故弄玄虚和其他目的，这是所有映射中最危险的。(这句话是C++编程思想中的原话)。因此, 你需要谨慎使用 reinterpret_cast。

### 4）dynamic_cast

用法为 dynamic_cast<type-id> (expression)。
几个特点如下：

1. 其他三种都是编译时完成的，dynamic_cast 是运行时处理的，运行时要进行类型检查。
2. 不能用于内置的基本数据类型的强制转换
3. dynamic_cast 要求 <> 内所描述的目标类型必须为指针或引用。dynamic_cast 转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回 nullptr
4. 在类的转换时，在类层次间进行上行转换（子类指针指向父类指针）时，dynamic_cast 和 static_cast 的效果是一样的。在进行下行转换（父类指针转化为子类指针）时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全。 向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。
5. 使用 dynamic_cast 进行转换的，基类中一定要有虚函数，否则编译不通过（类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义）。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表（C++中的虚函数基本原理这篇文章写得不错，https://blog.csdn.net/xiejingfa/article/details/50454819）。

## 迭代器失效的情况
